// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Live.proto

#ifndef PROTOBUF_IM_2eLive_2eproto__INCLUDED
#define PROTOBUF_IM_2eLive_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace IM {
namespace Live {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_IM_2eLive_2eproto();
void protobuf_AssignDesc_IM_2eLive_2eproto();
void protobuf_ShutdownFile_IM_2eLive_2eproto();

class IMLiveLoginRoomReq;
class IMLiveLoginRoomResp;
class IMLiveLogoutRoomReq;
class IMLiveLogoutRoomResp;
class IMLiveData;
class IMLiveSetRoomForbiddenStatusReq;
class IMLiveSetRoomForbiddenStatusResp;
class IMLiveGetRoomForbiddenStatusReq;
class IMLiveGetRoomForbiddenStatusResp;
class IMLiveGetRoomInfoReq;
class IMLiveGetRoomInfoResp;
class IMLiveKickUser;
class IMLiveUserOfflineException;
class IMLiveRoomClose;

// ===================================================================

class IMLiveLoginRoomReq : public ::google::protobuf::MessageLite {
 public:
  IMLiveLoginRoomReq();
  virtual ~IMLiveLoginRoomReq();

  IMLiveLoginRoomReq(const IMLiveLoginRoomReq& from);

  inline IMLiveLoginRoomReq& operator=(const IMLiveLoginRoomReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMLiveLoginRoomReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMLiveLoginRoomReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMLiveLoginRoomReq* other);

  // implements Message ----------------------------------------------

  IMLiveLoginRoomReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMLiveLoginRoomReq& from);
  void MergeFrom(const IMLiveLoginRoomReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_im_id = 1;
  inline bool has_user_im_id() const;
  inline void clear_user_im_id();
  static const int kUserImIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_im_id() const;
  inline void set_user_im_id(::google::protobuf::uint32 value);

  // required uint32 live_id = 2;
  inline bool has_live_id() const;
  inline void clear_live_id();
  static const int kLiveIdFieldNumber = 2;
  inline ::google::protobuf::uint32 live_id() const;
  inline void set_live_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Live.IMLiveLoginRoomReq)
 private:
  inline void set_has_user_im_id();
  inline void clear_has_user_im_id();
  inline void set_has_live_id();
  inline void clear_has_live_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_im_id_;
  ::google::protobuf::uint32 live_id_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eLive_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eLive_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eLive_2eproto();
  friend void protobuf_ShutdownFile_IM_2eLive_2eproto();

  void InitAsDefaultInstance();
  static IMLiveLoginRoomReq* default_instance_;
};
// -------------------------------------------------------------------

class IMLiveLoginRoomResp : public ::google::protobuf::MessageLite {
 public:
  IMLiveLoginRoomResp();
  virtual ~IMLiveLoginRoomResp();

  IMLiveLoginRoomResp(const IMLiveLoginRoomResp& from);

  inline IMLiveLoginRoomResp& operator=(const IMLiveLoginRoomResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMLiveLoginRoomResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMLiveLoginRoomResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMLiveLoginRoomResp* other);

  // implements Message ----------------------------------------------

  IMLiveLoginRoomResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMLiveLoginRoomResp& from);
  void MergeFrom(const IMLiveLoginRoomResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_im_id = 1;
  inline bool has_user_im_id() const;
  inline void clear_user_im_id();
  static const int kUserImIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_im_id() const;
  inline void set_user_im_id(::google::protobuf::uint32 value);

  // required uint32 live_id = 2;
  inline bool has_live_id() const;
  inline void clear_live_id();
  static const int kLiveIdFieldNumber = 2;
  inline ::google::protobuf::uint32 live_id() const;
  inline void set_live_id(::google::protobuf::uint32 value);

  // required uint32 room_cnt = 3;
  inline bool has_room_cnt() const;
  inline void clear_room_cnt();
  static const int kRoomCntFieldNumber = 3;
  inline ::google::protobuf::uint32 room_cnt() const;
  inline void set_room_cnt(::google::protobuf::uint32 value);

  // repeated uint32 member_list = 4;
  inline int member_list_size() const;
  inline void clear_member_list();
  static const int kMemberListFieldNumber = 4;
  inline ::google::protobuf::uint32 member_list(int index) const;
  inline void set_member_list(int index, ::google::protobuf::uint32 value);
  inline void add_member_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      member_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_member_list();

  // required uint32 result = 5;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 5;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // required string user_name = 6;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 6;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required string user_portrait = 7;
  inline bool has_user_portrait() const;
  inline void clear_user_portrait();
  static const int kUserPortraitFieldNumber = 7;
  inline const ::std::string& user_portrait() const;
  inline void set_user_portrait(const ::std::string& value);
  inline void set_user_portrait(const char* value);
  inline void set_user_portrait(const char* value, size_t size);
  inline ::std::string* mutable_user_portrait();
  inline ::std::string* release_user_portrait();
  inline void set_allocated_user_portrait(::std::string* user_portrait);

  // required uint32 forbidden_status = 8;
  inline bool has_forbidden_status() const;
  inline void clear_forbidden_status();
  static const int kForbiddenStatusFieldNumber = 8;
  inline ::google::protobuf::uint32 forbidden_status() const;
  inline void set_forbidden_status(::google::protobuf::uint32 value);

  // optional uint32 last_live_id = 9;
  inline bool has_last_live_id() const;
  inline void clear_last_live_id();
  static const int kLastLiveIdFieldNumber = 9;
  inline ::google::protobuf::uint32 last_live_id() const;
  inline void set_last_live_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Live.IMLiveLoginRoomResp)
 private:
  inline void set_has_user_im_id();
  inline void clear_has_user_im_id();
  inline void set_has_live_id();
  inline void clear_has_live_id();
  inline void set_has_room_cnt();
  inline void clear_has_room_cnt();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_user_portrait();
  inline void clear_has_user_portrait();
  inline void set_has_forbidden_status();
  inline void clear_has_forbidden_status();
  inline void set_has_last_live_id();
  inline void clear_has_last_live_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_im_id_;
  ::google::protobuf::uint32 live_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > member_list_;
  ::google::protobuf::uint32 room_cnt_;
  ::google::protobuf::uint32 result_;
  ::std::string* user_name_;
  ::std::string* user_portrait_;
  ::google::protobuf::uint32 forbidden_status_;
  ::google::protobuf::uint32 last_live_id_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eLive_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eLive_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eLive_2eproto();
  friend void protobuf_ShutdownFile_IM_2eLive_2eproto();

  void InitAsDefaultInstance();
  static IMLiveLoginRoomResp* default_instance_;
};
// -------------------------------------------------------------------

class IMLiveLogoutRoomReq : public ::google::protobuf::MessageLite {
 public:
  IMLiveLogoutRoomReq();
  virtual ~IMLiveLogoutRoomReq();

  IMLiveLogoutRoomReq(const IMLiveLogoutRoomReq& from);

  inline IMLiveLogoutRoomReq& operator=(const IMLiveLogoutRoomReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMLiveLogoutRoomReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMLiveLogoutRoomReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMLiveLogoutRoomReq* other);

  // implements Message ----------------------------------------------

  IMLiveLogoutRoomReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMLiveLogoutRoomReq& from);
  void MergeFrom(const IMLiveLogoutRoomReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_im_id = 1;
  inline bool has_user_im_id() const;
  inline void clear_user_im_id();
  static const int kUserImIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_im_id() const;
  inline void set_user_im_id(::google::protobuf::uint32 value);

  // required uint32 live_id = 2;
  inline bool has_live_id() const;
  inline void clear_live_id();
  static const int kLiveIdFieldNumber = 2;
  inline ::google::protobuf::uint32 live_id() const;
  inline void set_live_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Live.IMLiveLogoutRoomReq)
 private:
  inline void set_has_user_im_id();
  inline void clear_has_user_im_id();
  inline void set_has_live_id();
  inline void clear_has_live_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_im_id_;
  ::google::protobuf::uint32 live_id_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eLive_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eLive_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eLive_2eproto();
  friend void protobuf_ShutdownFile_IM_2eLive_2eproto();

  void InitAsDefaultInstance();
  static IMLiveLogoutRoomReq* default_instance_;
};
// -------------------------------------------------------------------

class IMLiveLogoutRoomResp : public ::google::protobuf::MessageLite {
 public:
  IMLiveLogoutRoomResp();
  virtual ~IMLiveLogoutRoomResp();

  IMLiveLogoutRoomResp(const IMLiveLogoutRoomResp& from);

  inline IMLiveLogoutRoomResp& operator=(const IMLiveLogoutRoomResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMLiveLogoutRoomResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMLiveLogoutRoomResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMLiveLogoutRoomResp* other);

  // implements Message ----------------------------------------------

  IMLiveLogoutRoomResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMLiveLogoutRoomResp& from);
  void MergeFrom(const IMLiveLogoutRoomResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_im_id = 1;
  inline bool has_user_im_id() const;
  inline void clear_user_im_id();
  static const int kUserImIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_im_id() const;
  inline void set_user_im_id(::google::protobuf::uint32 value);

  // required uint32 live_id = 2;
  inline bool has_live_id() const;
  inline void clear_live_id();
  static const int kLiveIdFieldNumber = 2;
  inline ::google::protobuf::uint32 live_id() const;
  inline void set_live_id(::google::protobuf::uint32 value);

  // required uint32 room_cnt = 3;
  inline bool has_room_cnt() const;
  inline void clear_room_cnt();
  static const int kRoomCntFieldNumber = 3;
  inline ::google::protobuf::uint32 room_cnt() const;
  inline void set_room_cnt(::google::protobuf::uint32 value);

  // repeated uint32 member_list = 4;
  inline int member_list_size() const;
  inline void clear_member_list();
  static const int kMemberListFieldNumber = 4;
  inline ::google::protobuf::uint32 member_list(int index) const;
  inline void set_member_list(int index, ::google::protobuf::uint32 value);
  inline void add_member_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      member_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_member_list();

  // required uint32 result = 5;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 5;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // required string user_name = 6;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 6;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required string user_portrait = 7;
  inline bool has_user_portrait() const;
  inline void clear_user_portrait();
  static const int kUserPortraitFieldNumber = 7;
  inline const ::std::string& user_portrait() const;
  inline void set_user_portrait(const ::std::string& value);
  inline void set_user_portrait(const char* value);
  inline void set_user_portrait(const char* value, size_t size);
  inline ::std::string* mutable_user_portrait();
  inline ::std::string* release_user_portrait();
  inline void set_allocated_user_portrait(::std::string* user_portrait);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Live.IMLiveLogoutRoomResp)
 private:
  inline void set_has_user_im_id();
  inline void clear_has_user_im_id();
  inline void set_has_live_id();
  inline void clear_has_live_id();
  inline void set_has_room_cnt();
  inline void clear_has_room_cnt();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_user_portrait();
  inline void clear_has_user_portrait();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_im_id_;
  ::google::protobuf::uint32 live_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > member_list_;
  ::google::protobuf::uint32 room_cnt_;
  ::google::protobuf::uint32 result_;
  ::std::string* user_name_;
  ::std::string* user_portrait_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eLive_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eLive_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eLive_2eproto();
  friend void protobuf_ShutdownFile_IM_2eLive_2eproto();

  void InitAsDefaultInstance();
  static IMLiveLogoutRoomResp* default_instance_;
};
// -------------------------------------------------------------------

class IMLiveData : public ::google::protobuf::MessageLite {
 public:
  IMLiveData();
  virtual ~IMLiveData();

  IMLiveData(const IMLiveData& from);

  inline IMLiveData& operator=(const IMLiveData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMLiveData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMLiveData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMLiveData* other);

  // implements Message ----------------------------------------------

  IMLiveData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMLiveData& from);
  void MergeFrom(const IMLiveData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 from_user_id = 1;
  inline bool has_from_user_id() const;
  inline void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 from_user_id() const;
  inline void set_from_user_id(::google::protobuf::uint32 value);

  // required uint32 to_session_id = 2;
  inline bool has_to_session_id() const;
  inline void clear_to_session_id();
  static const int kToSessionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 to_session_id() const;
  inline void set_to_session_id(::google::protobuf::uint32 value);

  // optional string from_user_name = 3;
  inline bool has_from_user_name() const;
  inline void clear_from_user_name();
  static const int kFromUserNameFieldNumber = 3;
  inline const ::std::string& from_user_name() const;
  inline void set_from_user_name(const ::std::string& value);
  inline void set_from_user_name(const char* value);
  inline void set_from_user_name(const char* value, size_t size);
  inline ::std::string* mutable_from_user_name();
  inline ::std::string* release_from_user_name();
  inline void set_allocated_from_user_name(::std::string* from_user_name);

  // optional string from_user_portrait = 4;
  inline bool has_from_user_portrait() const;
  inline void clear_from_user_portrait();
  static const int kFromUserPortraitFieldNumber = 4;
  inline const ::std::string& from_user_portrait() const;
  inline void set_from_user_portrait(const ::std::string& value);
  inline void set_from_user_portrait(const char* value);
  inline void set_from_user_portrait(const char* value, size_t size);
  inline ::std::string* mutable_from_user_portrait();
  inline ::std::string* release_from_user_portrait();
  inline void set_allocated_from_user_portrait(::std::string* from_user_portrait);

  // required bytes msg_data = 5;
  inline bool has_msg_data() const;
  inline void clear_msg_data();
  static const int kMsgDataFieldNumber = 5;
  inline const ::std::string& msg_data() const;
  inline void set_msg_data(const ::std::string& value);
  inline void set_msg_data(const char* value);
  inline void set_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_msg_data();
  inline ::std::string* release_msg_data();
  inline void set_allocated_msg_data(::std::string* msg_data);

  // required uint32 msg_type = 6;
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 6;
  inline ::google::protobuf::uint32 msg_type() const;
  inline void set_msg_type(::google::protobuf::uint32 value);

  // required uint32 create_time = 7;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 7;
  inline ::google::protobuf::uint32 create_time() const;
  inline void set_create_time(::google::protobuf::uint32 value);

  // repeated uint32 member_list = 8;
  inline int member_list_size() const;
  inline void clear_member_list();
  static const int kMemberListFieldNumber = 8;
  inline ::google::protobuf::uint32 member_list(int index) const;
  inline void set_member_list(int index, ::google::protobuf::uint32 value);
  inline void add_member_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      member_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_member_list();

  // required uint32 result = 9;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 9;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // optional uint32 record_id = 10;
  inline bool has_record_id() const;
  inline void clear_record_id();
  static const int kRecordIdFieldNumber = 10;
  inline ::google::protobuf::uint32 record_id() const;
  inline void set_record_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Live.IMLiveData)
 private:
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_to_session_id();
  inline void clear_has_to_session_id();
  inline void set_has_from_user_name();
  inline void clear_has_from_user_name();
  inline void set_has_from_user_portrait();
  inline void clear_has_from_user_portrait();
  inline void set_has_msg_data();
  inline void clear_has_msg_data();
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_record_id();
  inline void clear_has_record_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_session_id_;
  ::std::string* from_user_name_;
  ::std::string* from_user_portrait_;
  ::std::string* msg_data_;
  ::google::protobuf::uint32 msg_type_;
  ::google::protobuf::uint32 create_time_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > member_list_;
  ::google::protobuf::uint32 result_;
  ::google::protobuf::uint32 record_id_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eLive_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eLive_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eLive_2eproto();
  friend void protobuf_ShutdownFile_IM_2eLive_2eproto();

  void InitAsDefaultInstance();
  static IMLiveData* default_instance_;
};
// -------------------------------------------------------------------

class IMLiveSetRoomForbiddenStatusReq : public ::google::protobuf::MessageLite {
 public:
  IMLiveSetRoomForbiddenStatusReq();
  virtual ~IMLiveSetRoomForbiddenStatusReq();

  IMLiveSetRoomForbiddenStatusReq(const IMLiveSetRoomForbiddenStatusReq& from);

  inline IMLiveSetRoomForbiddenStatusReq& operator=(const IMLiveSetRoomForbiddenStatusReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMLiveSetRoomForbiddenStatusReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMLiveSetRoomForbiddenStatusReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMLiveSetRoomForbiddenStatusReq* other);

  // implements Message ----------------------------------------------

  IMLiveSetRoomForbiddenStatusReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMLiveSetRoomForbiddenStatusReq& from);
  void MergeFrom(const IMLiveSetRoomForbiddenStatusReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_im_id = 1;
  inline bool has_user_im_id() const;
  inline void clear_user_im_id();
  static const int kUserImIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_im_id() const;
  inline void set_user_im_id(::google::protobuf::uint32 value);

  // required uint32 live_id = 2;
  inline bool has_live_id() const;
  inline void clear_live_id();
  static const int kLiveIdFieldNumber = 2;
  inline ::google::protobuf::uint32 live_id() const;
  inline void set_live_id(::google::protobuf::uint32 value);

  // required uint32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Live.IMLiveSetRoomForbiddenStatusReq)
 private:
  inline void set_has_user_im_id();
  inline void clear_has_user_im_id();
  inline void set_has_live_id();
  inline void clear_has_live_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_im_id_;
  ::google::protobuf::uint32 live_id_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eLive_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eLive_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eLive_2eproto();
  friend void protobuf_ShutdownFile_IM_2eLive_2eproto();

  void InitAsDefaultInstance();
  static IMLiveSetRoomForbiddenStatusReq* default_instance_;
};
// -------------------------------------------------------------------

class IMLiveSetRoomForbiddenStatusResp : public ::google::protobuf::MessageLite {
 public:
  IMLiveSetRoomForbiddenStatusResp();
  virtual ~IMLiveSetRoomForbiddenStatusResp();

  IMLiveSetRoomForbiddenStatusResp(const IMLiveSetRoomForbiddenStatusResp& from);

  inline IMLiveSetRoomForbiddenStatusResp& operator=(const IMLiveSetRoomForbiddenStatusResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMLiveSetRoomForbiddenStatusResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMLiveSetRoomForbiddenStatusResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMLiveSetRoomForbiddenStatusResp* other);

  // implements Message ----------------------------------------------

  IMLiveSetRoomForbiddenStatusResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMLiveSetRoomForbiddenStatusResp& from);
  void MergeFrom(const IMLiveSetRoomForbiddenStatusResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_im_id = 1;
  inline bool has_user_im_id() const;
  inline void clear_user_im_id();
  static const int kUserImIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_im_id() const;
  inline void set_user_im_id(::google::protobuf::uint32 value);

  // required uint32 live_id = 2;
  inline bool has_live_id() const;
  inline void clear_live_id();
  static const int kLiveIdFieldNumber = 2;
  inline ::google::protobuf::uint32 live_id() const;
  inline void set_live_id(::google::protobuf::uint32 value);

  // required uint32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // repeated uint32 member_list = 4;
  inline int member_list_size() const;
  inline void clear_member_list();
  static const int kMemberListFieldNumber = 4;
  inline ::google::protobuf::uint32 member_list(int index) const;
  inline void set_member_list(int index, ::google::protobuf::uint32 value);
  inline void add_member_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      member_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_member_list();

  // required uint32 result = 5;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 5;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Live.IMLiveSetRoomForbiddenStatusResp)
 private:
  inline void set_has_user_im_id();
  inline void clear_has_user_im_id();
  inline void set_has_live_id();
  inline void clear_has_live_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_im_id_;
  ::google::protobuf::uint32 live_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > member_list_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 result_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eLive_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eLive_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eLive_2eproto();
  friend void protobuf_ShutdownFile_IM_2eLive_2eproto();

  void InitAsDefaultInstance();
  static IMLiveSetRoomForbiddenStatusResp* default_instance_;
};
// -------------------------------------------------------------------

class IMLiveGetRoomForbiddenStatusReq : public ::google::protobuf::MessageLite {
 public:
  IMLiveGetRoomForbiddenStatusReq();
  virtual ~IMLiveGetRoomForbiddenStatusReq();

  IMLiveGetRoomForbiddenStatusReq(const IMLiveGetRoomForbiddenStatusReq& from);

  inline IMLiveGetRoomForbiddenStatusReq& operator=(const IMLiveGetRoomForbiddenStatusReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMLiveGetRoomForbiddenStatusReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMLiveGetRoomForbiddenStatusReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMLiveGetRoomForbiddenStatusReq* other);

  // implements Message ----------------------------------------------

  IMLiveGetRoomForbiddenStatusReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMLiveGetRoomForbiddenStatusReq& from);
  void MergeFrom(const IMLiveGetRoomForbiddenStatusReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_im_id = 1;
  inline bool has_user_im_id() const;
  inline void clear_user_im_id();
  static const int kUserImIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_im_id() const;
  inline void set_user_im_id(::google::protobuf::uint32 value);

  // required uint32 live_id = 2;
  inline bool has_live_id() const;
  inline void clear_live_id();
  static const int kLiveIdFieldNumber = 2;
  inline ::google::protobuf::uint32 live_id() const;
  inline void set_live_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Live.IMLiveGetRoomForbiddenStatusReq)
 private:
  inline void set_has_user_im_id();
  inline void clear_has_user_im_id();
  inline void set_has_live_id();
  inline void clear_has_live_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_im_id_;
  ::google::protobuf::uint32 live_id_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eLive_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eLive_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eLive_2eproto();
  friend void protobuf_ShutdownFile_IM_2eLive_2eproto();

  void InitAsDefaultInstance();
  static IMLiveGetRoomForbiddenStatusReq* default_instance_;
};
// -------------------------------------------------------------------

class IMLiveGetRoomForbiddenStatusResp : public ::google::protobuf::MessageLite {
 public:
  IMLiveGetRoomForbiddenStatusResp();
  virtual ~IMLiveGetRoomForbiddenStatusResp();

  IMLiveGetRoomForbiddenStatusResp(const IMLiveGetRoomForbiddenStatusResp& from);

  inline IMLiveGetRoomForbiddenStatusResp& operator=(const IMLiveGetRoomForbiddenStatusResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMLiveGetRoomForbiddenStatusResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMLiveGetRoomForbiddenStatusResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMLiveGetRoomForbiddenStatusResp* other);

  // implements Message ----------------------------------------------

  IMLiveGetRoomForbiddenStatusResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMLiveGetRoomForbiddenStatusResp& from);
  void MergeFrom(const IMLiveGetRoomForbiddenStatusResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_im_id = 1;
  inline bool has_user_im_id() const;
  inline void clear_user_im_id();
  static const int kUserImIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_im_id() const;
  inline void set_user_im_id(::google::protobuf::uint32 value);

  // required uint32 live_id = 2;
  inline bool has_live_id() const;
  inline void clear_live_id();
  static const int kLiveIdFieldNumber = 2;
  inline ::google::protobuf::uint32 live_id() const;
  inline void set_live_id(::google::protobuf::uint32 value);

  // required uint32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // required uint32 result = 4;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 4;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Live.IMLiveGetRoomForbiddenStatusResp)
 private:
  inline void set_has_user_im_id();
  inline void clear_has_user_im_id();
  inline void set_has_live_id();
  inline void clear_has_live_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_im_id_;
  ::google::protobuf::uint32 live_id_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 result_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eLive_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eLive_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eLive_2eproto();
  friend void protobuf_ShutdownFile_IM_2eLive_2eproto();

  void InitAsDefaultInstance();
  static IMLiveGetRoomForbiddenStatusResp* default_instance_;
};
// -------------------------------------------------------------------

class IMLiveGetRoomInfoReq : public ::google::protobuf::MessageLite {
 public:
  IMLiveGetRoomInfoReq();
  virtual ~IMLiveGetRoomInfoReq();

  IMLiveGetRoomInfoReq(const IMLiveGetRoomInfoReq& from);

  inline IMLiveGetRoomInfoReq& operator=(const IMLiveGetRoomInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMLiveGetRoomInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMLiveGetRoomInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMLiveGetRoomInfoReq* other);

  // implements Message ----------------------------------------------

  IMLiveGetRoomInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMLiveGetRoomInfoReq& from);
  void MergeFrom(const IMLiveGetRoomInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_im_id = 1;
  inline bool has_user_im_id() const;
  inline void clear_user_im_id();
  static const int kUserImIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_im_id() const;
  inline void set_user_im_id(::google::protobuf::uint32 value);

  // required uint32 live_id = 2;
  inline bool has_live_id() const;
  inline void clear_live_id();
  static const int kLiveIdFieldNumber = 2;
  inline ::google::protobuf::uint32 live_id() const;
  inline void set_live_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Live.IMLiveGetRoomInfoReq)
 private:
  inline void set_has_user_im_id();
  inline void clear_has_user_im_id();
  inline void set_has_live_id();
  inline void clear_has_live_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_im_id_;
  ::google::protobuf::uint32 live_id_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eLive_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eLive_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eLive_2eproto();
  friend void protobuf_ShutdownFile_IM_2eLive_2eproto();

  void InitAsDefaultInstance();
  static IMLiveGetRoomInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class IMLiveGetRoomInfoResp : public ::google::protobuf::MessageLite {
 public:
  IMLiveGetRoomInfoResp();
  virtual ~IMLiveGetRoomInfoResp();

  IMLiveGetRoomInfoResp(const IMLiveGetRoomInfoResp& from);

  inline IMLiveGetRoomInfoResp& operator=(const IMLiveGetRoomInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMLiveGetRoomInfoResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMLiveGetRoomInfoResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMLiveGetRoomInfoResp* other);

  // implements Message ----------------------------------------------

  IMLiveGetRoomInfoResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMLiveGetRoomInfoResp& from);
  void MergeFrom(const IMLiveGetRoomInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_im_id = 1;
  inline bool has_user_im_id() const;
  inline void clear_user_im_id();
  static const int kUserImIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_im_id() const;
  inline void set_user_im_id(::google::protobuf::uint32 value);

  // required uint32 live_id = 2;
  inline bool has_live_id() const;
  inline void clear_live_id();
  static const int kLiveIdFieldNumber = 2;
  inline ::google::protobuf::uint32 live_id() const;
  inline void set_live_id(::google::protobuf::uint32 value);

  // required uint32 forbidden_status = 3;
  inline bool has_forbidden_status() const;
  inline void clear_forbidden_status();
  static const int kForbiddenStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 forbidden_status() const;
  inline void set_forbidden_status(::google::protobuf::uint32 value);

  // required uint32 room_cnt = 4;
  inline bool has_room_cnt() const;
  inline void clear_room_cnt();
  static const int kRoomCntFieldNumber = 4;
  inline ::google::protobuf::uint32 room_cnt() const;
  inline void set_room_cnt(::google::protobuf::uint32 value);

  // repeated uint32 member_list = 5;
  inline int member_list_size() const;
  inline void clear_member_list();
  static const int kMemberListFieldNumber = 5;
  inline ::google::protobuf::uint32 member_list(int index) const;
  inline void set_member_list(int index, ::google::protobuf::uint32 value);
  inline void add_member_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      member_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_member_list();

  // required uint32 result = 6;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 6;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Live.IMLiveGetRoomInfoResp)
 private:
  inline void set_has_user_im_id();
  inline void clear_has_user_im_id();
  inline void set_has_live_id();
  inline void clear_has_live_id();
  inline void set_has_forbidden_status();
  inline void clear_has_forbidden_status();
  inline void set_has_room_cnt();
  inline void clear_has_room_cnt();
  inline void set_has_result();
  inline void clear_has_result();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_im_id_;
  ::google::protobuf::uint32 live_id_;
  ::google::protobuf::uint32 forbidden_status_;
  ::google::protobuf::uint32 room_cnt_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > member_list_;
  ::google::protobuf::uint32 result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eLive_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eLive_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eLive_2eproto();
  friend void protobuf_ShutdownFile_IM_2eLive_2eproto();

  void InitAsDefaultInstance();
  static IMLiveGetRoomInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class IMLiveKickUser : public ::google::protobuf::MessageLite {
 public:
  IMLiveKickUser();
  virtual ~IMLiveKickUser();

  IMLiveKickUser(const IMLiveKickUser& from);

  inline IMLiveKickUser& operator=(const IMLiveKickUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMLiveKickUser& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMLiveKickUser* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMLiveKickUser* other);

  // implements Message ----------------------------------------------

  IMLiveKickUser* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMLiveKickUser& from);
  void MergeFrom(const IMLiveKickUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_im_id = 1;
  inline bool has_user_im_id() const;
  inline void clear_user_im_id();
  static const int kUserImIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_im_id() const;
  inline void set_user_im_id(::google::protobuf::uint32 value);

  // required uint32 live_id = 2;
  inline bool has_live_id() const;
  inline void clear_live_id();
  static const int kLiveIdFieldNumber = 2;
  inline ::google::protobuf::uint32 live_id() const;
  inline void set_live_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Live.IMLiveKickUser)
 private:
  inline void set_has_user_im_id();
  inline void clear_has_user_im_id();
  inline void set_has_live_id();
  inline void clear_has_live_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_im_id_;
  ::google::protobuf::uint32 live_id_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eLive_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eLive_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eLive_2eproto();
  friend void protobuf_ShutdownFile_IM_2eLive_2eproto();

  void InitAsDefaultInstance();
  static IMLiveKickUser* default_instance_;
};
// -------------------------------------------------------------------

class IMLiveUserOfflineException : public ::google::protobuf::MessageLite {
 public:
  IMLiveUserOfflineException();
  virtual ~IMLiveUserOfflineException();

  IMLiveUserOfflineException(const IMLiveUserOfflineException& from);

  inline IMLiveUserOfflineException& operator=(const IMLiveUserOfflineException& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMLiveUserOfflineException& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMLiveUserOfflineException* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMLiveUserOfflineException* other);

  // implements Message ----------------------------------------------

  IMLiveUserOfflineException* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMLiveUserOfflineException& from);
  void MergeFrom(const IMLiveUserOfflineException& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_im_id = 1;
  inline bool has_user_im_id() const;
  inline void clear_user_im_id();
  static const int kUserImIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_im_id() const;
  inline void set_user_im_id(::google::protobuf::uint32 value);

  // required uint32 live_id = 2;
  inline bool has_live_id() const;
  inline void clear_live_id();
  static const int kLiveIdFieldNumber = 2;
  inline ::google::protobuf::uint32 live_id() const;
  inline void set_live_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Live.IMLiveUserOfflineException)
 private:
  inline void set_has_user_im_id();
  inline void clear_has_user_im_id();
  inline void set_has_live_id();
  inline void clear_has_live_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_im_id_;
  ::google::protobuf::uint32 live_id_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eLive_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eLive_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eLive_2eproto();
  friend void protobuf_ShutdownFile_IM_2eLive_2eproto();

  void InitAsDefaultInstance();
  static IMLiveUserOfflineException* default_instance_;
};
// -------------------------------------------------------------------

class IMLiveRoomClose : public ::google::protobuf::MessageLite {
 public:
  IMLiveRoomClose();
  virtual ~IMLiveRoomClose();

  IMLiveRoomClose(const IMLiveRoomClose& from);

  inline IMLiveRoomClose& operator=(const IMLiveRoomClose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMLiveRoomClose& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMLiveRoomClose* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMLiveRoomClose* other);

  // implements Message ----------------------------------------------

  IMLiveRoomClose* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMLiveRoomClose& from);
  void MergeFrom(const IMLiveRoomClose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 live_id = 1;
  inline bool has_live_id() const;
  inline void clear_live_id();
  static const int kLiveIdFieldNumber = 1;
  inline ::google::protobuf::uint32 live_id() const;
  inline void set_live_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Live.IMLiveRoomClose)
 private:
  inline void set_has_live_id();
  inline void clear_has_live_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 live_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eLive_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eLive_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eLive_2eproto();
  friend void protobuf_ShutdownFile_IM_2eLive_2eproto();

  void InitAsDefaultInstance();
  static IMLiveRoomClose* default_instance_;
};
// ===================================================================


// ===================================================================

// IMLiveLoginRoomReq

// required uint32 user_im_id = 1;
inline bool IMLiveLoginRoomReq::has_user_im_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMLiveLoginRoomReq::set_has_user_im_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMLiveLoginRoomReq::clear_has_user_im_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMLiveLoginRoomReq::clear_user_im_id() {
  user_im_id_ = 0u;
  clear_has_user_im_id();
}
inline ::google::protobuf::uint32 IMLiveLoginRoomReq::user_im_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLoginRoomReq.user_im_id)
  return user_im_id_;
}
inline void IMLiveLoginRoomReq::set_user_im_id(::google::protobuf::uint32 value) {
  set_has_user_im_id();
  user_im_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLoginRoomReq.user_im_id)
}

// required uint32 live_id = 2;
inline bool IMLiveLoginRoomReq::has_live_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMLiveLoginRoomReq::set_has_live_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMLiveLoginRoomReq::clear_has_live_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMLiveLoginRoomReq::clear_live_id() {
  live_id_ = 0u;
  clear_has_live_id();
}
inline ::google::protobuf::uint32 IMLiveLoginRoomReq::live_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLoginRoomReq.live_id)
  return live_id_;
}
inline void IMLiveLoginRoomReq::set_live_id(::google::protobuf::uint32 value) {
  set_has_live_id();
  live_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLoginRoomReq.live_id)
}

// optional bytes attach_data = 20;
inline bool IMLiveLoginRoomReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMLiveLoginRoomReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMLiveLoginRoomReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMLiveLoginRoomReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMLiveLoginRoomReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLoginRoomReq.attach_data)
  return *attach_data_;
}
inline void IMLiveLoginRoomReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLoginRoomReq.attach_data)
}
inline void IMLiveLoginRoomReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveLoginRoomReq.attach_data)
}
inline void IMLiveLoginRoomReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveLoginRoomReq.attach_data)
}
inline ::std::string* IMLiveLoginRoomReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveLoginRoomReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMLiveLoginRoomReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveLoginRoomReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveLoginRoomReq.attach_data)
}

// -------------------------------------------------------------------

// IMLiveLoginRoomResp

// required uint32 user_im_id = 1;
inline bool IMLiveLoginRoomResp::has_user_im_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMLiveLoginRoomResp::set_has_user_im_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMLiveLoginRoomResp::clear_has_user_im_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMLiveLoginRoomResp::clear_user_im_id() {
  user_im_id_ = 0u;
  clear_has_user_im_id();
}
inline ::google::protobuf::uint32 IMLiveLoginRoomResp::user_im_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLoginRoomResp.user_im_id)
  return user_im_id_;
}
inline void IMLiveLoginRoomResp::set_user_im_id(::google::protobuf::uint32 value) {
  set_has_user_im_id();
  user_im_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLoginRoomResp.user_im_id)
}

// required uint32 live_id = 2;
inline bool IMLiveLoginRoomResp::has_live_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMLiveLoginRoomResp::set_has_live_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMLiveLoginRoomResp::clear_has_live_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMLiveLoginRoomResp::clear_live_id() {
  live_id_ = 0u;
  clear_has_live_id();
}
inline ::google::protobuf::uint32 IMLiveLoginRoomResp::live_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLoginRoomResp.live_id)
  return live_id_;
}
inline void IMLiveLoginRoomResp::set_live_id(::google::protobuf::uint32 value) {
  set_has_live_id();
  live_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLoginRoomResp.live_id)
}

// required uint32 room_cnt = 3;
inline bool IMLiveLoginRoomResp::has_room_cnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMLiveLoginRoomResp::set_has_room_cnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMLiveLoginRoomResp::clear_has_room_cnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMLiveLoginRoomResp::clear_room_cnt() {
  room_cnt_ = 0u;
  clear_has_room_cnt();
}
inline ::google::protobuf::uint32 IMLiveLoginRoomResp::room_cnt() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLoginRoomResp.room_cnt)
  return room_cnt_;
}
inline void IMLiveLoginRoomResp::set_room_cnt(::google::protobuf::uint32 value) {
  set_has_room_cnt();
  room_cnt_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLoginRoomResp.room_cnt)
}

// repeated uint32 member_list = 4;
inline int IMLiveLoginRoomResp::member_list_size() const {
  return member_list_.size();
}
inline void IMLiveLoginRoomResp::clear_member_list() {
  member_list_.Clear();
}
inline ::google::protobuf::uint32 IMLiveLoginRoomResp::member_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLoginRoomResp.member_list)
  return member_list_.Get(index);
}
inline void IMLiveLoginRoomResp::set_member_list(int index, ::google::protobuf::uint32 value) {
  member_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLoginRoomResp.member_list)
}
inline void IMLiveLoginRoomResp::add_member_list(::google::protobuf::uint32 value) {
  member_list_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Live.IMLiveLoginRoomResp.member_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMLiveLoginRoomResp::member_list() const {
  // @@protoc_insertion_point(field_list:IM.Live.IMLiveLoginRoomResp.member_list)
  return member_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMLiveLoginRoomResp::mutable_member_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Live.IMLiveLoginRoomResp.member_list)
  return &member_list_;
}

// required uint32 result = 5;
inline bool IMLiveLoginRoomResp::has_result() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMLiveLoginRoomResp::set_has_result() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMLiveLoginRoomResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMLiveLoginRoomResp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 IMLiveLoginRoomResp::result() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLoginRoomResp.result)
  return result_;
}
inline void IMLiveLoginRoomResp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLoginRoomResp.result)
}

// required string user_name = 6;
inline bool IMLiveLoginRoomResp::has_user_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMLiveLoginRoomResp::set_has_user_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMLiveLoginRoomResp::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMLiveLoginRoomResp::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& IMLiveLoginRoomResp::user_name() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLoginRoomResp.user_name)
  return *user_name_;
}
inline void IMLiveLoginRoomResp::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLoginRoomResp.user_name)
}
inline void IMLiveLoginRoomResp::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveLoginRoomResp.user_name)
}
inline void IMLiveLoginRoomResp::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveLoginRoomResp.user_name)
}
inline ::std::string* IMLiveLoginRoomResp::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveLoginRoomResp.user_name)
  return user_name_;
}
inline ::std::string* IMLiveLoginRoomResp::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveLoginRoomResp::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveLoginRoomResp.user_name)
}

// required string user_portrait = 7;
inline bool IMLiveLoginRoomResp::has_user_portrait() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMLiveLoginRoomResp::set_has_user_portrait() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMLiveLoginRoomResp::clear_has_user_portrait() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMLiveLoginRoomResp::clear_user_portrait() {
  if (user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_->clear();
  }
  clear_has_user_portrait();
}
inline const ::std::string& IMLiveLoginRoomResp::user_portrait() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLoginRoomResp.user_portrait)
  return *user_portrait_;
}
inline void IMLiveLoginRoomResp::set_user_portrait(const ::std::string& value) {
  set_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_ = new ::std::string;
  }
  user_portrait_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLoginRoomResp.user_portrait)
}
inline void IMLiveLoginRoomResp::set_user_portrait(const char* value) {
  set_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_ = new ::std::string;
  }
  user_portrait_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveLoginRoomResp.user_portrait)
}
inline void IMLiveLoginRoomResp::set_user_portrait(const char* value, size_t size) {
  set_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_ = new ::std::string;
  }
  user_portrait_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveLoginRoomResp.user_portrait)
}
inline ::std::string* IMLiveLoginRoomResp::mutable_user_portrait() {
  set_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveLoginRoomResp.user_portrait)
  return user_portrait_;
}
inline ::std::string* IMLiveLoginRoomResp::release_user_portrait() {
  clear_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_portrait_;
    user_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveLoginRoomResp::set_allocated_user_portrait(::std::string* user_portrait) {
  if (user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_portrait_;
  }
  if (user_portrait) {
    set_has_user_portrait();
    user_portrait_ = user_portrait;
  } else {
    clear_has_user_portrait();
    user_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveLoginRoomResp.user_portrait)
}

// required uint32 forbidden_status = 8;
inline bool IMLiveLoginRoomResp::has_forbidden_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IMLiveLoginRoomResp::set_has_forbidden_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IMLiveLoginRoomResp::clear_has_forbidden_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IMLiveLoginRoomResp::clear_forbidden_status() {
  forbidden_status_ = 0u;
  clear_has_forbidden_status();
}
inline ::google::protobuf::uint32 IMLiveLoginRoomResp::forbidden_status() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLoginRoomResp.forbidden_status)
  return forbidden_status_;
}
inline void IMLiveLoginRoomResp::set_forbidden_status(::google::protobuf::uint32 value) {
  set_has_forbidden_status();
  forbidden_status_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLoginRoomResp.forbidden_status)
}

// optional uint32 last_live_id = 9;
inline bool IMLiveLoginRoomResp::has_last_live_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IMLiveLoginRoomResp::set_has_last_live_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IMLiveLoginRoomResp::clear_has_last_live_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IMLiveLoginRoomResp::clear_last_live_id() {
  last_live_id_ = 0u;
  clear_has_last_live_id();
}
inline ::google::protobuf::uint32 IMLiveLoginRoomResp::last_live_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLoginRoomResp.last_live_id)
  return last_live_id_;
}
inline void IMLiveLoginRoomResp::set_last_live_id(::google::protobuf::uint32 value) {
  set_has_last_live_id();
  last_live_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLoginRoomResp.last_live_id)
}

// optional bytes attach_data = 20;
inline bool IMLiveLoginRoomResp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IMLiveLoginRoomResp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000200u;
}
inline void IMLiveLoginRoomResp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void IMLiveLoginRoomResp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMLiveLoginRoomResp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLoginRoomResp.attach_data)
  return *attach_data_;
}
inline void IMLiveLoginRoomResp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLoginRoomResp.attach_data)
}
inline void IMLiveLoginRoomResp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveLoginRoomResp.attach_data)
}
inline void IMLiveLoginRoomResp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveLoginRoomResp.attach_data)
}
inline ::std::string* IMLiveLoginRoomResp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveLoginRoomResp.attach_data)
  return attach_data_;
}
inline ::std::string* IMLiveLoginRoomResp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveLoginRoomResp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveLoginRoomResp.attach_data)
}

// -------------------------------------------------------------------

// IMLiveLogoutRoomReq

// required uint32 user_im_id = 1;
inline bool IMLiveLogoutRoomReq::has_user_im_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMLiveLogoutRoomReq::set_has_user_im_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMLiveLogoutRoomReq::clear_has_user_im_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMLiveLogoutRoomReq::clear_user_im_id() {
  user_im_id_ = 0u;
  clear_has_user_im_id();
}
inline ::google::protobuf::uint32 IMLiveLogoutRoomReq::user_im_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLogoutRoomReq.user_im_id)
  return user_im_id_;
}
inline void IMLiveLogoutRoomReq::set_user_im_id(::google::protobuf::uint32 value) {
  set_has_user_im_id();
  user_im_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLogoutRoomReq.user_im_id)
}

// required uint32 live_id = 2;
inline bool IMLiveLogoutRoomReq::has_live_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMLiveLogoutRoomReq::set_has_live_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMLiveLogoutRoomReq::clear_has_live_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMLiveLogoutRoomReq::clear_live_id() {
  live_id_ = 0u;
  clear_has_live_id();
}
inline ::google::protobuf::uint32 IMLiveLogoutRoomReq::live_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLogoutRoomReq.live_id)
  return live_id_;
}
inline void IMLiveLogoutRoomReq::set_live_id(::google::protobuf::uint32 value) {
  set_has_live_id();
  live_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLogoutRoomReq.live_id)
}

// optional bytes attach_data = 20;
inline bool IMLiveLogoutRoomReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMLiveLogoutRoomReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMLiveLogoutRoomReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMLiveLogoutRoomReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMLiveLogoutRoomReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLogoutRoomReq.attach_data)
  return *attach_data_;
}
inline void IMLiveLogoutRoomReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLogoutRoomReq.attach_data)
}
inline void IMLiveLogoutRoomReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveLogoutRoomReq.attach_data)
}
inline void IMLiveLogoutRoomReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveLogoutRoomReq.attach_data)
}
inline ::std::string* IMLiveLogoutRoomReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveLogoutRoomReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMLiveLogoutRoomReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveLogoutRoomReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveLogoutRoomReq.attach_data)
}

// -------------------------------------------------------------------

// IMLiveLogoutRoomResp

// required uint32 user_im_id = 1;
inline bool IMLiveLogoutRoomResp::has_user_im_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMLiveLogoutRoomResp::set_has_user_im_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMLiveLogoutRoomResp::clear_has_user_im_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMLiveLogoutRoomResp::clear_user_im_id() {
  user_im_id_ = 0u;
  clear_has_user_im_id();
}
inline ::google::protobuf::uint32 IMLiveLogoutRoomResp::user_im_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLogoutRoomResp.user_im_id)
  return user_im_id_;
}
inline void IMLiveLogoutRoomResp::set_user_im_id(::google::protobuf::uint32 value) {
  set_has_user_im_id();
  user_im_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLogoutRoomResp.user_im_id)
}

// required uint32 live_id = 2;
inline bool IMLiveLogoutRoomResp::has_live_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMLiveLogoutRoomResp::set_has_live_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMLiveLogoutRoomResp::clear_has_live_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMLiveLogoutRoomResp::clear_live_id() {
  live_id_ = 0u;
  clear_has_live_id();
}
inline ::google::protobuf::uint32 IMLiveLogoutRoomResp::live_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLogoutRoomResp.live_id)
  return live_id_;
}
inline void IMLiveLogoutRoomResp::set_live_id(::google::protobuf::uint32 value) {
  set_has_live_id();
  live_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLogoutRoomResp.live_id)
}

// required uint32 room_cnt = 3;
inline bool IMLiveLogoutRoomResp::has_room_cnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMLiveLogoutRoomResp::set_has_room_cnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMLiveLogoutRoomResp::clear_has_room_cnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMLiveLogoutRoomResp::clear_room_cnt() {
  room_cnt_ = 0u;
  clear_has_room_cnt();
}
inline ::google::protobuf::uint32 IMLiveLogoutRoomResp::room_cnt() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLogoutRoomResp.room_cnt)
  return room_cnt_;
}
inline void IMLiveLogoutRoomResp::set_room_cnt(::google::protobuf::uint32 value) {
  set_has_room_cnt();
  room_cnt_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLogoutRoomResp.room_cnt)
}

// repeated uint32 member_list = 4;
inline int IMLiveLogoutRoomResp::member_list_size() const {
  return member_list_.size();
}
inline void IMLiveLogoutRoomResp::clear_member_list() {
  member_list_.Clear();
}
inline ::google::protobuf::uint32 IMLiveLogoutRoomResp::member_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLogoutRoomResp.member_list)
  return member_list_.Get(index);
}
inline void IMLiveLogoutRoomResp::set_member_list(int index, ::google::protobuf::uint32 value) {
  member_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLogoutRoomResp.member_list)
}
inline void IMLiveLogoutRoomResp::add_member_list(::google::protobuf::uint32 value) {
  member_list_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Live.IMLiveLogoutRoomResp.member_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMLiveLogoutRoomResp::member_list() const {
  // @@protoc_insertion_point(field_list:IM.Live.IMLiveLogoutRoomResp.member_list)
  return member_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMLiveLogoutRoomResp::mutable_member_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Live.IMLiveLogoutRoomResp.member_list)
  return &member_list_;
}

// required uint32 result = 5;
inline bool IMLiveLogoutRoomResp::has_result() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMLiveLogoutRoomResp::set_has_result() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMLiveLogoutRoomResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMLiveLogoutRoomResp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 IMLiveLogoutRoomResp::result() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLogoutRoomResp.result)
  return result_;
}
inline void IMLiveLogoutRoomResp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLogoutRoomResp.result)
}

// required string user_name = 6;
inline bool IMLiveLogoutRoomResp::has_user_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMLiveLogoutRoomResp::set_has_user_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMLiveLogoutRoomResp::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMLiveLogoutRoomResp::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& IMLiveLogoutRoomResp::user_name() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLogoutRoomResp.user_name)
  return *user_name_;
}
inline void IMLiveLogoutRoomResp::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLogoutRoomResp.user_name)
}
inline void IMLiveLogoutRoomResp::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveLogoutRoomResp.user_name)
}
inline void IMLiveLogoutRoomResp::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveLogoutRoomResp.user_name)
}
inline ::std::string* IMLiveLogoutRoomResp::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveLogoutRoomResp.user_name)
  return user_name_;
}
inline ::std::string* IMLiveLogoutRoomResp::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveLogoutRoomResp::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveLogoutRoomResp.user_name)
}

// required string user_portrait = 7;
inline bool IMLiveLogoutRoomResp::has_user_portrait() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMLiveLogoutRoomResp::set_has_user_portrait() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMLiveLogoutRoomResp::clear_has_user_portrait() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMLiveLogoutRoomResp::clear_user_portrait() {
  if (user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_->clear();
  }
  clear_has_user_portrait();
}
inline const ::std::string& IMLiveLogoutRoomResp::user_portrait() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLogoutRoomResp.user_portrait)
  return *user_portrait_;
}
inline void IMLiveLogoutRoomResp::set_user_portrait(const ::std::string& value) {
  set_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_ = new ::std::string;
  }
  user_portrait_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLogoutRoomResp.user_portrait)
}
inline void IMLiveLogoutRoomResp::set_user_portrait(const char* value) {
  set_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_ = new ::std::string;
  }
  user_portrait_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveLogoutRoomResp.user_portrait)
}
inline void IMLiveLogoutRoomResp::set_user_portrait(const char* value, size_t size) {
  set_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_ = new ::std::string;
  }
  user_portrait_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveLogoutRoomResp.user_portrait)
}
inline ::std::string* IMLiveLogoutRoomResp::mutable_user_portrait() {
  set_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveLogoutRoomResp.user_portrait)
  return user_portrait_;
}
inline ::std::string* IMLiveLogoutRoomResp::release_user_portrait() {
  clear_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_portrait_;
    user_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveLogoutRoomResp::set_allocated_user_portrait(::std::string* user_portrait) {
  if (user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_portrait_;
  }
  if (user_portrait) {
    set_has_user_portrait();
    user_portrait_ = user_portrait;
  } else {
    clear_has_user_portrait();
    user_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveLogoutRoomResp.user_portrait)
}

// optional bytes attach_data = 20;
inline bool IMLiveLogoutRoomResp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IMLiveLogoutRoomResp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IMLiveLogoutRoomResp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IMLiveLogoutRoomResp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMLiveLogoutRoomResp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveLogoutRoomResp.attach_data)
  return *attach_data_;
}
inline void IMLiveLogoutRoomResp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveLogoutRoomResp.attach_data)
}
inline void IMLiveLogoutRoomResp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveLogoutRoomResp.attach_data)
}
inline void IMLiveLogoutRoomResp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveLogoutRoomResp.attach_data)
}
inline ::std::string* IMLiveLogoutRoomResp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveLogoutRoomResp.attach_data)
  return attach_data_;
}
inline ::std::string* IMLiveLogoutRoomResp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveLogoutRoomResp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveLogoutRoomResp.attach_data)
}

// -------------------------------------------------------------------

// IMLiveData

// required uint32 from_user_id = 1;
inline bool IMLiveData::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMLiveData::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMLiveData::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMLiveData::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 IMLiveData::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveData.from_user_id)
  return from_user_id_;
}
inline void IMLiveData::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveData.from_user_id)
}

// required uint32 to_session_id = 2;
inline bool IMLiveData::has_to_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMLiveData::set_has_to_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMLiveData::clear_has_to_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMLiveData::clear_to_session_id() {
  to_session_id_ = 0u;
  clear_has_to_session_id();
}
inline ::google::protobuf::uint32 IMLiveData::to_session_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveData.to_session_id)
  return to_session_id_;
}
inline void IMLiveData::set_to_session_id(::google::protobuf::uint32 value) {
  set_has_to_session_id();
  to_session_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveData.to_session_id)
}

// optional string from_user_name = 3;
inline bool IMLiveData::has_from_user_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMLiveData::set_has_from_user_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMLiveData::clear_has_from_user_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMLiveData::clear_from_user_name() {
  if (from_user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_user_name_->clear();
  }
  clear_has_from_user_name();
}
inline const ::std::string& IMLiveData::from_user_name() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveData.from_user_name)
  return *from_user_name_;
}
inline void IMLiveData::set_from_user_name(const ::std::string& value) {
  set_has_from_user_name();
  if (from_user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_user_name_ = new ::std::string;
  }
  from_user_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveData.from_user_name)
}
inline void IMLiveData::set_from_user_name(const char* value) {
  set_has_from_user_name();
  if (from_user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_user_name_ = new ::std::string;
  }
  from_user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveData.from_user_name)
}
inline void IMLiveData::set_from_user_name(const char* value, size_t size) {
  set_has_from_user_name();
  if (from_user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_user_name_ = new ::std::string;
  }
  from_user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveData.from_user_name)
}
inline ::std::string* IMLiveData::mutable_from_user_name() {
  set_has_from_user_name();
  if (from_user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveData.from_user_name)
  return from_user_name_;
}
inline ::std::string* IMLiveData::release_from_user_name() {
  clear_has_from_user_name();
  if (from_user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = from_user_name_;
    from_user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveData::set_allocated_from_user_name(::std::string* from_user_name) {
  if (from_user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete from_user_name_;
  }
  if (from_user_name) {
    set_has_from_user_name();
    from_user_name_ = from_user_name;
  } else {
    clear_has_from_user_name();
    from_user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveData.from_user_name)
}

// optional string from_user_portrait = 4;
inline bool IMLiveData::has_from_user_portrait() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMLiveData::set_has_from_user_portrait() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMLiveData::clear_has_from_user_portrait() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMLiveData::clear_from_user_portrait() {
  if (from_user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_user_portrait_->clear();
  }
  clear_has_from_user_portrait();
}
inline const ::std::string& IMLiveData::from_user_portrait() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveData.from_user_portrait)
  return *from_user_portrait_;
}
inline void IMLiveData::set_from_user_portrait(const ::std::string& value) {
  set_has_from_user_portrait();
  if (from_user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_user_portrait_ = new ::std::string;
  }
  from_user_portrait_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveData.from_user_portrait)
}
inline void IMLiveData::set_from_user_portrait(const char* value) {
  set_has_from_user_portrait();
  if (from_user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_user_portrait_ = new ::std::string;
  }
  from_user_portrait_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveData.from_user_portrait)
}
inline void IMLiveData::set_from_user_portrait(const char* value, size_t size) {
  set_has_from_user_portrait();
  if (from_user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_user_portrait_ = new ::std::string;
  }
  from_user_portrait_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveData.from_user_portrait)
}
inline ::std::string* IMLiveData::mutable_from_user_portrait() {
  set_has_from_user_portrait();
  if (from_user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_user_portrait_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveData.from_user_portrait)
  return from_user_portrait_;
}
inline ::std::string* IMLiveData::release_from_user_portrait() {
  clear_has_from_user_portrait();
  if (from_user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = from_user_portrait_;
    from_user_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveData::set_allocated_from_user_portrait(::std::string* from_user_portrait) {
  if (from_user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete from_user_portrait_;
  }
  if (from_user_portrait) {
    set_has_from_user_portrait();
    from_user_portrait_ = from_user_portrait;
  } else {
    clear_has_from_user_portrait();
    from_user_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveData.from_user_portrait)
}

// required bytes msg_data = 5;
inline bool IMLiveData::has_msg_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMLiveData::set_has_msg_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMLiveData::clear_has_msg_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMLiveData::clear_msg_data() {
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_->clear();
  }
  clear_has_msg_data();
}
inline const ::std::string& IMLiveData::msg_data() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveData.msg_data)
  return *msg_data_;
}
inline void IMLiveData::set_msg_data(const ::std::string& value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveData.msg_data)
}
inline void IMLiveData::set_msg_data(const char* value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveData.msg_data)
}
inline void IMLiveData::set_msg_data(const void* value, size_t size) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveData.msg_data)
}
inline ::std::string* IMLiveData::mutable_msg_data() {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveData.msg_data)
  return msg_data_;
}
inline ::std::string* IMLiveData::release_msg_data() {
  clear_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_data_;
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveData::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_data_;
  }
  if (msg_data) {
    set_has_msg_data();
    msg_data_ = msg_data;
  } else {
    clear_has_msg_data();
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveData.msg_data)
}

// required uint32 msg_type = 6;
inline bool IMLiveData::has_msg_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMLiveData::set_has_msg_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMLiveData::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMLiveData::clear_msg_type() {
  msg_type_ = 0u;
  clear_has_msg_type();
}
inline ::google::protobuf::uint32 IMLiveData::msg_type() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveData.msg_type)
  return msg_type_;
}
inline void IMLiveData::set_msg_type(::google::protobuf::uint32 value) {
  set_has_msg_type();
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveData.msg_type)
}

// required uint32 create_time = 7;
inline bool IMLiveData::has_create_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMLiveData::set_has_create_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMLiveData::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMLiveData::clear_create_time() {
  create_time_ = 0u;
  clear_has_create_time();
}
inline ::google::protobuf::uint32 IMLiveData::create_time() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveData.create_time)
  return create_time_;
}
inline void IMLiveData::set_create_time(::google::protobuf::uint32 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveData.create_time)
}

// repeated uint32 member_list = 8;
inline int IMLiveData::member_list_size() const {
  return member_list_.size();
}
inline void IMLiveData::clear_member_list() {
  member_list_.Clear();
}
inline ::google::protobuf::uint32 IMLiveData::member_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveData.member_list)
  return member_list_.Get(index);
}
inline void IMLiveData::set_member_list(int index, ::google::protobuf::uint32 value) {
  member_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveData.member_list)
}
inline void IMLiveData::add_member_list(::google::protobuf::uint32 value) {
  member_list_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Live.IMLiveData.member_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMLiveData::member_list() const {
  // @@protoc_insertion_point(field_list:IM.Live.IMLiveData.member_list)
  return member_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMLiveData::mutable_member_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Live.IMLiveData.member_list)
  return &member_list_;
}

// required uint32 result = 9;
inline bool IMLiveData::has_result() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IMLiveData::set_has_result() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IMLiveData::clear_has_result() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IMLiveData::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 IMLiveData::result() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveData.result)
  return result_;
}
inline void IMLiveData::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveData.result)
}

// optional uint32 record_id = 10;
inline bool IMLiveData::has_record_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IMLiveData::set_has_record_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void IMLiveData::clear_has_record_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void IMLiveData::clear_record_id() {
  record_id_ = 0u;
  clear_has_record_id();
}
inline ::google::protobuf::uint32 IMLiveData::record_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveData.record_id)
  return record_id_;
}
inline void IMLiveData::set_record_id(::google::protobuf::uint32 value) {
  set_has_record_id();
  record_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveData.record_id)
}

// optional bytes attach_data = 20;
inline bool IMLiveData::has_attach_data() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void IMLiveData::set_has_attach_data() {
  _has_bits_[0] |= 0x00000400u;
}
inline void IMLiveData::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void IMLiveData::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMLiveData::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveData.attach_data)
  return *attach_data_;
}
inline void IMLiveData::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveData.attach_data)
}
inline void IMLiveData::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveData.attach_data)
}
inline void IMLiveData::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveData.attach_data)
}
inline ::std::string* IMLiveData::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveData.attach_data)
  return attach_data_;
}
inline ::std::string* IMLiveData::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveData::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveData.attach_data)
}

// -------------------------------------------------------------------

// IMLiveSetRoomForbiddenStatusReq

// required uint32 user_im_id = 1;
inline bool IMLiveSetRoomForbiddenStatusReq::has_user_im_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMLiveSetRoomForbiddenStatusReq::set_has_user_im_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMLiveSetRoomForbiddenStatusReq::clear_has_user_im_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMLiveSetRoomForbiddenStatusReq::clear_user_im_id() {
  user_im_id_ = 0u;
  clear_has_user_im_id();
}
inline ::google::protobuf::uint32 IMLiveSetRoomForbiddenStatusReq::user_im_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveSetRoomForbiddenStatusReq.user_im_id)
  return user_im_id_;
}
inline void IMLiveSetRoomForbiddenStatusReq::set_user_im_id(::google::protobuf::uint32 value) {
  set_has_user_im_id();
  user_im_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveSetRoomForbiddenStatusReq.user_im_id)
}

// required uint32 live_id = 2;
inline bool IMLiveSetRoomForbiddenStatusReq::has_live_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMLiveSetRoomForbiddenStatusReq::set_has_live_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMLiveSetRoomForbiddenStatusReq::clear_has_live_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMLiveSetRoomForbiddenStatusReq::clear_live_id() {
  live_id_ = 0u;
  clear_has_live_id();
}
inline ::google::protobuf::uint32 IMLiveSetRoomForbiddenStatusReq::live_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveSetRoomForbiddenStatusReq.live_id)
  return live_id_;
}
inline void IMLiveSetRoomForbiddenStatusReq::set_live_id(::google::protobuf::uint32 value) {
  set_has_live_id();
  live_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveSetRoomForbiddenStatusReq.live_id)
}

// required uint32 status = 3;
inline bool IMLiveSetRoomForbiddenStatusReq::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMLiveSetRoomForbiddenStatusReq::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMLiveSetRoomForbiddenStatusReq::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMLiveSetRoomForbiddenStatusReq::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 IMLiveSetRoomForbiddenStatusReq::status() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveSetRoomForbiddenStatusReq.status)
  return status_;
}
inline void IMLiveSetRoomForbiddenStatusReq::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveSetRoomForbiddenStatusReq.status)
}

// optional bytes attach_data = 20;
inline bool IMLiveSetRoomForbiddenStatusReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMLiveSetRoomForbiddenStatusReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMLiveSetRoomForbiddenStatusReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMLiveSetRoomForbiddenStatusReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMLiveSetRoomForbiddenStatusReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveSetRoomForbiddenStatusReq.attach_data)
  return *attach_data_;
}
inline void IMLiveSetRoomForbiddenStatusReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveSetRoomForbiddenStatusReq.attach_data)
}
inline void IMLiveSetRoomForbiddenStatusReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveSetRoomForbiddenStatusReq.attach_data)
}
inline void IMLiveSetRoomForbiddenStatusReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveSetRoomForbiddenStatusReq.attach_data)
}
inline ::std::string* IMLiveSetRoomForbiddenStatusReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveSetRoomForbiddenStatusReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMLiveSetRoomForbiddenStatusReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveSetRoomForbiddenStatusReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveSetRoomForbiddenStatusReq.attach_data)
}

// -------------------------------------------------------------------

// IMLiveSetRoomForbiddenStatusResp

// required uint32 user_im_id = 1;
inline bool IMLiveSetRoomForbiddenStatusResp::has_user_im_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMLiveSetRoomForbiddenStatusResp::set_has_user_im_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMLiveSetRoomForbiddenStatusResp::clear_has_user_im_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMLiveSetRoomForbiddenStatusResp::clear_user_im_id() {
  user_im_id_ = 0u;
  clear_has_user_im_id();
}
inline ::google::protobuf::uint32 IMLiveSetRoomForbiddenStatusResp::user_im_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveSetRoomForbiddenStatusResp.user_im_id)
  return user_im_id_;
}
inline void IMLiveSetRoomForbiddenStatusResp::set_user_im_id(::google::protobuf::uint32 value) {
  set_has_user_im_id();
  user_im_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveSetRoomForbiddenStatusResp.user_im_id)
}

// required uint32 live_id = 2;
inline bool IMLiveSetRoomForbiddenStatusResp::has_live_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMLiveSetRoomForbiddenStatusResp::set_has_live_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMLiveSetRoomForbiddenStatusResp::clear_has_live_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMLiveSetRoomForbiddenStatusResp::clear_live_id() {
  live_id_ = 0u;
  clear_has_live_id();
}
inline ::google::protobuf::uint32 IMLiveSetRoomForbiddenStatusResp::live_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveSetRoomForbiddenStatusResp.live_id)
  return live_id_;
}
inline void IMLiveSetRoomForbiddenStatusResp::set_live_id(::google::protobuf::uint32 value) {
  set_has_live_id();
  live_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveSetRoomForbiddenStatusResp.live_id)
}

// required uint32 status = 3;
inline bool IMLiveSetRoomForbiddenStatusResp::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMLiveSetRoomForbiddenStatusResp::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMLiveSetRoomForbiddenStatusResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMLiveSetRoomForbiddenStatusResp::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 IMLiveSetRoomForbiddenStatusResp::status() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveSetRoomForbiddenStatusResp.status)
  return status_;
}
inline void IMLiveSetRoomForbiddenStatusResp::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveSetRoomForbiddenStatusResp.status)
}

// repeated uint32 member_list = 4;
inline int IMLiveSetRoomForbiddenStatusResp::member_list_size() const {
  return member_list_.size();
}
inline void IMLiveSetRoomForbiddenStatusResp::clear_member_list() {
  member_list_.Clear();
}
inline ::google::protobuf::uint32 IMLiveSetRoomForbiddenStatusResp::member_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveSetRoomForbiddenStatusResp.member_list)
  return member_list_.Get(index);
}
inline void IMLiveSetRoomForbiddenStatusResp::set_member_list(int index, ::google::protobuf::uint32 value) {
  member_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveSetRoomForbiddenStatusResp.member_list)
}
inline void IMLiveSetRoomForbiddenStatusResp::add_member_list(::google::protobuf::uint32 value) {
  member_list_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Live.IMLiveSetRoomForbiddenStatusResp.member_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMLiveSetRoomForbiddenStatusResp::member_list() const {
  // @@protoc_insertion_point(field_list:IM.Live.IMLiveSetRoomForbiddenStatusResp.member_list)
  return member_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMLiveSetRoomForbiddenStatusResp::mutable_member_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Live.IMLiveSetRoomForbiddenStatusResp.member_list)
  return &member_list_;
}

// required uint32 result = 5;
inline bool IMLiveSetRoomForbiddenStatusResp::has_result() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMLiveSetRoomForbiddenStatusResp::set_has_result() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMLiveSetRoomForbiddenStatusResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMLiveSetRoomForbiddenStatusResp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 IMLiveSetRoomForbiddenStatusResp::result() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveSetRoomForbiddenStatusResp.result)
  return result_;
}
inline void IMLiveSetRoomForbiddenStatusResp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveSetRoomForbiddenStatusResp.result)
}

// optional bytes attach_data = 20;
inline bool IMLiveSetRoomForbiddenStatusResp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMLiveSetRoomForbiddenStatusResp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMLiveSetRoomForbiddenStatusResp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMLiveSetRoomForbiddenStatusResp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMLiveSetRoomForbiddenStatusResp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveSetRoomForbiddenStatusResp.attach_data)
  return *attach_data_;
}
inline void IMLiveSetRoomForbiddenStatusResp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveSetRoomForbiddenStatusResp.attach_data)
}
inline void IMLiveSetRoomForbiddenStatusResp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveSetRoomForbiddenStatusResp.attach_data)
}
inline void IMLiveSetRoomForbiddenStatusResp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveSetRoomForbiddenStatusResp.attach_data)
}
inline ::std::string* IMLiveSetRoomForbiddenStatusResp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveSetRoomForbiddenStatusResp.attach_data)
  return attach_data_;
}
inline ::std::string* IMLiveSetRoomForbiddenStatusResp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveSetRoomForbiddenStatusResp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveSetRoomForbiddenStatusResp.attach_data)
}

// -------------------------------------------------------------------

// IMLiveGetRoomForbiddenStatusReq

// required uint32 user_im_id = 1;
inline bool IMLiveGetRoomForbiddenStatusReq::has_user_im_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMLiveGetRoomForbiddenStatusReq::set_has_user_im_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMLiveGetRoomForbiddenStatusReq::clear_has_user_im_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMLiveGetRoomForbiddenStatusReq::clear_user_im_id() {
  user_im_id_ = 0u;
  clear_has_user_im_id();
}
inline ::google::protobuf::uint32 IMLiveGetRoomForbiddenStatusReq::user_im_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveGetRoomForbiddenStatusReq.user_im_id)
  return user_im_id_;
}
inline void IMLiveGetRoomForbiddenStatusReq::set_user_im_id(::google::protobuf::uint32 value) {
  set_has_user_im_id();
  user_im_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveGetRoomForbiddenStatusReq.user_im_id)
}

// required uint32 live_id = 2;
inline bool IMLiveGetRoomForbiddenStatusReq::has_live_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMLiveGetRoomForbiddenStatusReq::set_has_live_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMLiveGetRoomForbiddenStatusReq::clear_has_live_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMLiveGetRoomForbiddenStatusReq::clear_live_id() {
  live_id_ = 0u;
  clear_has_live_id();
}
inline ::google::protobuf::uint32 IMLiveGetRoomForbiddenStatusReq::live_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveGetRoomForbiddenStatusReq.live_id)
  return live_id_;
}
inline void IMLiveGetRoomForbiddenStatusReq::set_live_id(::google::protobuf::uint32 value) {
  set_has_live_id();
  live_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveGetRoomForbiddenStatusReq.live_id)
}

// optional bytes attach_data = 20;
inline bool IMLiveGetRoomForbiddenStatusReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMLiveGetRoomForbiddenStatusReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMLiveGetRoomForbiddenStatusReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMLiveGetRoomForbiddenStatusReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMLiveGetRoomForbiddenStatusReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveGetRoomForbiddenStatusReq.attach_data)
  return *attach_data_;
}
inline void IMLiveGetRoomForbiddenStatusReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveGetRoomForbiddenStatusReq.attach_data)
}
inline void IMLiveGetRoomForbiddenStatusReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveGetRoomForbiddenStatusReq.attach_data)
}
inline void IMLiveGetRoomForbiddenStatusReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveGetRoomForbiddenStatusReq.attach_data)
}
inline ::std::string* IMLiveGetRoomForbiddenStatusReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveGetRoomForbiddenStatusReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMLiveGetRoomForbiddenStatusReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveGetRoomForbiddenStatusReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveGetRoomForbiddenStatusReq.attach_data)
}

// -------------------------------------------------------------------

// IMLiveGetRoomForbiddenStatusResp

// required uint32 user_im_id = 1;
inline bool IMLiveGetRoomForbiddenStatusResp::has_user_im_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMLiveGetRoomForbiddenStatusResp::set_has_user_im_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMLiveGetRoomForbiddenStatusResp::clear_has_user_im_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMLiveGetRoomForbiddenStatusResp::clear_user_im_id() {
  user_im_id_ = 0u;
  clear_has_user_im_id();
}
inline ::google::protobuf::uint32 IMLiveGetRoomForbiddenStatusResp::user_im_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveGetRoomForbiddenStatusResp.user_im_id)
  return user_im_id_;
}
inline void IMLiveGetRoomForbiddenStatusResp::set_user_im_id(::google::protobuf::uint32 value) {
  set_has_user_im_id();
  user_im_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveGetRoomForbiddenStatusResp.user_im_id)
}

// required uint32 live_id = 2;
inline bool IMLiveGetRoomForbiddenStatusResp::has_live_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMLiveGetRoomForbiddenStatusResp::set_has_live_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMLiveGetRoomForbiddenStatusResp::clear_has_live_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMLiveGetRoomForbiddenStatusResp::clear_live_id() {
  live_id_ = 0u;
  clear_has_live_id();
}
inline ::google::protobuf::uint32 IMLiveGetRoomForbiddenStatusResp::live_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveGetRoomForbiddenStatusResp.live_id)
  return live_id_;
}
inline void IMLiveGetRoomForbiddenStatusResp::set_live_id(::google::protobuf::uint32 value) {
  set_has_live_id();
  live_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveGetRoomForbiddenStatusResp.live_id)
}

// required uint32 status = 3;
inline bool IMLiveGetRoomForbiddenStatusResp::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMLiveGetRoomForbiddenStatusResp::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMLiveGetRoomForbiddenStatusResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMLiveGetRoomForbiddenStatusResp::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 IMLiveGetRoomForbiddenStatusResp::status() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveGetRoomForbiddenStatusResp.status)
  return status_;
}
inline void IMLiveGetRoomForbiddenStatusResp::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveGetRoomForbiddenStatusResp.status)
}

// required uint32 result = 4;
inline bool IMLiveGetRoomForbiddenStatusResp::has_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMLiveGetRoomForbiddenStatusResp::set_has_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMLiveGetRoomForbiddenStatusResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMLiveGetRoomForbiddenStatusResp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 IMLiveGetRoomForbiddenStatusResp::result() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveGetRoomForbiddenStatusResp.result)
  return result_;
}
inline void IMLiveGetRoomForbiddenStatusResp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveGetRoomForbiddenStatusResp.result)
}

// optional bytes attach_data = 20;
inline bool IMLiveGetRoomForbiddenStatusResp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMLiveGetRoomForbiddenStatusResp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMLiveGetRoomForbiddenStatusResp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMLiveGetRoomForbiddenStatusResp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMLiveGetRoomForbiddenStatusResp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveGetRoomForbiddenStatusResp.attach_data)
  return *attach_data_;
}
inline void IMLiveGetRoomForbiddenStatusResp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveGetRoomForbiddenStatusResp.attach_data)
}
inline void IMLiveGetRoomForbiddenStatusResp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveGetRoomForbiddenStatusResp.attach_data)
}
inline void IMLiveGetRoomForbiddenStatusResp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveGetRoomForbiddenStatusResp.attach_data)
}
inline ::std::string* IMLiveGetRoomForbiddenStatusResp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveGetRoomForbiddenStatusResp.attach_data)
  return attach_data_;
}
inline ::std::string* IMLiveGetRoomForbiddenStatusResp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveGetRoomForbiddenStatusResp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveGetRoomForbiddenStatusResp.attach_data)
}

// -------------------------------------------------------------------

// IMLiveGetRoomInfoReq

// required uint32 user_im_id = 1;
inline bool IMLiveGetRoomInfoReq::has_user_im_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMLiveGetRoomInfoReq::set_has_user_im_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMLiveGetRoomInfoReq::clear_has_user_im_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMLiveGetRoomInfoReq::clear_user_im_id() {
  user_im_id_ = 0u;
  clear_has_user_im_id();
}
inline ::google::protobuf::uint32 IMLiveGetRoomInfoReq::user_im_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveGetRoomInfoReq.user_im_id)
  return user_im_id_;
}
inline void IMLiveGetRoomInfoReq::set_user_im_id(::google::protobuf::uint32 value) {
  set_has_user_im_id();
  user_im_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveGetRoomInfoReq.user_im_id)
}

// required uint32 live_id = 2;
inline bool IMLiveGetRoomInfoReq::has_live_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMLiveGetRoomInfoReq::set_has_live_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMLiveGetRoomInfoReq::clear_has_live_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMLiveGetRoomInfoReq::clear_live_id() {
  live_id_ = 0u;
  clear_has_live_id();
}
inline ::google::protobuf::uint32 IMLiveGetRoomInfoReq::live_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveGetRoomInfoReq.live_id)
  return live_id_;
}
inline void IMLiveGetRoomInfoReq::set_live_id(::google::protobuf::uint32 value) {
  set_has_live_id();
  live_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveGetRoomInfoReq.live_id)
}

// optional bytes attach_data = 20;
inline bool IMLiveGetRoomInfoReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMLiveGetRoomInfoReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMLiveGetRoomInfoReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMLiveGetRoomInfoReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMLiveGetRoomInfoReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveGetRoomInfoReq.attach_data)
  return *attach_data_;
}
inline void IMLiveGetRoomInfoReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveGetRoomInfoReq.attach_data)
}
inline void IMLiveGetRoomInfoReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveGetRoomInfoReq.attach_data)
}
inline void IMLiveGetRoomInfoReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveGetRoomInfoReq.attach_data)
}
inline ::std::string* IMLiveGetRoomInfoReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveGetRoomInfoReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMLiveGetRoomInfoReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveGetRoomInfoReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveGetRoomInfoReq.attach_data)
}

// -------------------------------------------------------------------

// IMLiveGetRoomInfoResp

// required uint32 user_im_id = 1;
inline bool IMLiveGetRoomInfoResp::has_user_im_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMLiveGetRoomInfoResp::set_has_user_im_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMLiveGetRoomInfoResp::clear_has_user_im_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMLiveGetRoomInfoResp::clear_user_im_id() {
  user_im_id_ = 0u;
  clear_has_user_im_id();
}
inline ::google::protobuf::uint32 IMLiveGetRoomInfoResp::user_im_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveGetRoomInfoResp.user_im_id)
  return user_im_id_;
}
inline void IMLiveGetRoomInfoResp::set_user_im_id(::google::protobuf::uint32 value) {
  set_has_user_im_id();
  user_im_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveGetRoomInfoResp.user_im_id)
}

// required uint32 live_id = 2;
inline bool IMLiveGetRoomInfoResp::has_live_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMLiveGetRoomInfoResp::set_has_live_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMLiveGetRoomInfoResp::clear_has_live_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMLiveGetRoomInfoResp::clear_live_id() {
  live_id_ = 0u;
  clear_has_live_id();
}
inline ::google::protobuf::uint32 IMLiveGetRoomInfoResp::live_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveGetRoomInfoResp.live_id)
  return live_id_;
}
inline void IMLiveGetRoomInfoResp::set_live_id(::google::protobuf::uint32 value) {
  set_has_live_id();
  live_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveGetRoomInfoResp.live_id)
}

// required uint32 forbidden_status = 3;
inline bool IMLiveGetRoomInfoResp::has_forbidden_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMLiveGetRoomInfoResp::set_has_forbidden_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMLiveGetRoomInfoResp::clear_has_forbidden_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMLiveGetRoomInfoResp::clear_forbidden_status() {
  forbidden_status_ = 0u;
  clear_has_forbidden_status();
}
inline ::google::protobuf::uint32 IMLiveGetRoomInfoResp::forbidden_status() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveGetRoomInfoResp.forbidden_status)
  return forbidden_status_;
}
inline void IMLiveGetRoomInfoResp::set_forbidden_status(::google::protobuf::uint32 value) {
  set_has_forbidden_status();
  forbidden_status_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveGetRoomInfoResp.forbidden_status)
}

// required uint32 room_cnt = 4;
inline bool IMLiveGetRoomInfoResp::has_room_cnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMLiveGetRoomInfoResp::set_has_room_cnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMLiveGetRoomInfoResp::clear_has_room_cnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMLiveGetRoomInfoResp::clear_room_cnt() {
  room_cnt_ = 0u;
  clear_has_room_cnt();
}
inline ::google::protobuf::uint32 IMLiveGetRoomInfoResp::room_cnt() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveGetRoomInfoResp.room_cnt)
  return room_cnt_;
}
inline void IMLiveGetRoomInfoResp::set_room_cnt(::google::protobuf::uint32 value) {
  set_has_room_cnt();
  room_cnt_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveGetRoomInfoResp.room_cnt)
}

// repeated uint32 member_list = 5;
inline int IMLiveGetRoomInfoResp::member_list_size() const {
  return member_list_.size();
}
inline void IMLiveGetRoomInfoResp::clear_member_list() {
  member_list_.Clear();
}
inline ::google::protobuf::uint32 IMLiveGetRoomInfoResp::member_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveGetRoomInfoResp.member_list)
  return member_list_.Get(index);
}
inline void IMLiveGetRoomInfoResp::set_member_list(int index, ::google::protobuf::uint32 value) {
  member_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveGetRoomInfoResp.member_list)
}
inline void IMLiveGetRoomInfoResp::add_member_list(::google::protobuf::uint32 value) {
  member_list_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Live.IMLiveGetRoomInfoResp.member_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMLiveGetRoomInfoResp::member_list() const {
  // @@protoc_insertion_point(field_list:IM.Live.IMLiveGetRoomInfoResp.member_list)
  return member_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMLiveGetRoomInfoResp::mutable_member_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Live.IMLiveGetRoomInfoResp.member_list)
  return &member_list_;
}

// required uint32 result = 6;
inline bool IMLiveGetRoomInfoResp::has_result() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMLiveGetRoomInfoResp::set_has_result() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMLiveGetRoomInfoResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMLiveGetRoomInfoResp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 IMLiveGetRoomInfoResp::result() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveGetRoomInfoResp.result)
  return result_;
}
inline void IMLiveGetRoomInfoResp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveGetRoomInfoResp.result)
}

// -------------------------------------------------------------------

// IMLiveKickUser

// required uint32 user_im_id = 1;
inline bool IMLiveKickUser::has_user_im_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMLiveKickUser::set_has_user_im_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMLiveKickUser::clear_has_user_im_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMLiveKickUser::clear_user_im_id() {
  user_im_id_ = 0u;
  clear_has_user_im_id();
}
inline ::google::protobuf::uint32 IMLiveKickUser::user_im_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveKickUser.user_im_id)
  return user_im_id_;
}
inline void IMLiveKickUser::set_user_im_id(::google::protobuf::uint32 value) {
  set_has_user_im_id();
  user_im_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveKickUser.user_im_id)
}

// required uint32 live_id = 2;
inline bool IMLiveKickUser::has_live_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMLiveKickUser::set_has_live_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMLiveKickUser::clear_has_live_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMLiveKickUser::clear_live_id() {
  live_id_ = 0u;
  clear_has_live_id();
}
inline ::google::protobuf::uint32 IMLiveKickUser::live_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveKickUser.live_id)
  return live_id_;
}
inline void IMLiveKickUser::set_live_id(::google::protobuf::uint32 value) {
  set_has_live_id();
  live_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveKickUser.live_id)
}

// optional bytes attach_data = 20;
inline bool IMLiveKickUser::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMLiveKickUser::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMLiveKickUser::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMLiveKickUser::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMLiveKickUser::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveKickUser.attach_data)
  return *attach_data_;
}
inline void IMLiveKickUser::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveKickUser.attach_data)
}
inline void IMLiveKickUser::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveKickUser.attach_data)
}
inline void IMLiveKickUser::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveKickUser.attach_data)
}
inline ::std::string* IMLiveKickUser::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveKickUser.attach_data)
  return attach_data_;
}
inline ::std::string* IMLiveKickUser::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveKickUser::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveKickUser.attach_data)
}

// -------------------------------------------------------------------

// IMLiveUserOfflineException

// required uint32 user_im_id = 1;
inline bool IMLiveUserOfflineException::has_user_im_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMLiveUserOfflineException::set_has_user_im_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMLiveUserOfflineException::clear_has_user_im_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMLiveUserOfflineException::clear_user_im_id() {
  user_im_id_ = 0u;
  clear_has_user_im_id();
}
inline ::google::protobuf::uint32 IMLiveUserOfflineException::user_im_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveUserOfflineException.user_im_id)
  return user_im_id_;
}
inline void IMLiveUserOfflineException::set_user_im_id(::google::protobuf::uint32 value) {
  set_has_user_im_id();
  user_im_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveUserOfflineException.user_im_id)
}

// required uint32 live_id = 2;
inline bool IMLiveUserOfflineException::has_live_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMLiveUserOfflineException::set_has_live_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMLiveUserOfflineException::clear_has_live_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMLiveUserOfflineException::clear_live_id() {
  live_id_ = 0u;
  clear_has_live_id();
}
inline ::google::protobuf::uint32 IMLiveUserOfflineException::live_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveUserOfflineException.live_id)
  return live_id_;
}
inline void IMLiveUserOfflineException::set_live_id(::google::protobuf::uint32 value) {
  set_has_live_id();
  live_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveUserOfflineException.live_id)
}

// optional bytes attach_data = 20;
inline bool IMLiveUserOfflineException::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMLiveUserOfflineException::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMLiveUserOfflineException::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMLiveUserOfflineException::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMLiveUserOfflineException::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveUserOfflineException.attach_data)
  return *attach_data_;
}
inline void IMLiveUserOfflineException::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveUserOfflineException.attach_data)
}
inline void IMLiveUserOfflineException::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveUserOfflineException.attach_data)
}
inline void IMLiveUserOfflineException::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveUserOfflineException.attach_data)
}
inline ::std::string* IMLiveUserOfflineException::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveUserOfflineException.attach_data)
  return attach_data_;
}
inline ::std::string* IMLiveUserOfflineException::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveUserOfflineException::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveUserOfflineException.attach_data)
}

// -------------------------------------------------------------------

// IMLiveRoomClose

// required uint32 live_id = 1;
inline bool IMLiveRoomClose::has_live_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMLiveRoomClose::set_has_live_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMLiveRoomClose::clear_has_live_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMLiveRoomClose::clear_live_id() {
  live_id_ = 0u;
  clear_has_live_id();
}
inline ::google::protobuf::uint32 IMLiveRoomClose::live_id() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveRoomClose.live_id)
  return live_id_;
}
inline void IMLiveRoomClose::set_live_id(::google::protobuf::uint32 value) {
  set_has_live_id();
  live_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveRoomClose.live_id)
}

// optional bytes attach_data = 20;
inline bool IMLiveRoomClose::has_attach_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMLiveRoomClose::set_has_attach_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMLiveRoomClose::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMLiveRoomClose::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMLiveRoomClose::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Live.IMLiveRoomClose.attach_data)
  return *attach_data_;
}
inline void IMLiveRoomClose::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Live.IMLiveRoomClose.attach_data)
}
inline void IMLiveRoomClose::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Live.IMLiveRoomClose.attach_data)
}
inline void IMLiveRoomClose::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Live.IMLiveRoomClose.attach_data)
}
inline ::std::string* IMLiveRoomClose::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Live.IMLiveRoomClose.attach_data)
  return attach_data_;
}
inline ::std::string* IMLiveRoomClose::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMLiveRoomClose::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Live.IMLiveRoomClose.attach_data)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Live
}  // namespace IM

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IM_2eLive_2eproto__INCLUDED
