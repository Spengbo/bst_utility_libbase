// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Live.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "IM.Live.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace IM {
namespace Live {

void protobuf_ShutdownFile_IM_2eLive_2eproto() {
  delete IMLiveLoginRoomReq::default_instance_;
  delete IMLiveLoginRoomResp::default_instance_;
  delete IMLiveLogoutRoomReq::default_instance_;
  delete IMLiveLogoutRoomResp::default_instance_;
  delete IMLiveData::default_instance_;
  delete IMLiveSetRoomForbiddenStatusReq::default_instance_;
  delete IMLiveSetRoomForbiddenStatusResp::default_instance_;
  delete IMLiveGetRoomForbiddenStatusReq::default_instance_;
  delete IMLiveGetRoomForbiddenStatusResp::default_instance_;
  delete IMLiveGetRoomInfoReq::default_instance_;
  delete IMLiveGetRoomInfoResp::default_instance_;
  delete IMLiveKickUser::default_instance_;
  delete IMLiveUserOfflineException::default_instance_;
  delete IMLiveRoomClose::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_IM_2eLive_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_IM_2eLive_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  IMLiveLoginRoomReq::default_instance_ = new IMLiveLoginRoomReq();
  IMLiveLoginRoomResp::default_instance_ = new IMLiveLoginRoomResp();
  IMLiveLogoutRoomReq::default_instance_ = new IMLiveLogoutRoomReq();
  IMLiveLogoutRoomResp::default_instance_ = new IMLiveLogoutRoomResp();
  IMLiveData::default_instance_ = new IMLiveData();
  IMLiveSetRoomForbiddenStatusReq::default_instance_ = new IMLiveSetRoomForbiddenStatusReq();
  IMLiveSetRoomForbiddenStatusResp::default_instance_ = new IMLiveSetRoomForbiddenStatusResp();
  IMLiveGetRoomForbiddenStatusReq::default_instance_ = new IMLiveGetRoomForbiddenStatusReq();
  IMLiveGetRoomForbiddenStatusResp::default_instance_ = new IMLiveGetRoomForbiddenStatusResp();
  IMLiveGetRoomInfoReq::default_instance_ = new IMLiveGetRoomInfoReq();
  IMLiveGetRoomInfoResp::default_instance_ = new IMLiveGetRoomInfoResp();
  IMLiveKickUser::default_instance_ = new IMLiveKickUser();
  IMLiveUserOfflineException::default_instance_ = new IMLiveUserOfflineException();
  IMLiveRoomClose::default_instance_ = new IMLiveRoomClose();
  IMLiveLoginRoomReq::default_instance_->InitAsDefaultInstance();
  IMLiveLoginRoomResp::default_instance_->InitAsDefaultInstance();
  IMLiveLogoutRoomReq::default_instance_->InitAsDefaultInstance();
  IMLiveLogoutRoomResp::default_instance_->InitAsDefaultInstance();
  IMLiveData::default_instance_->InitAsDefaultInstance();
  IMLiveSetRoomForbiddenStatusReq::default_instance_->InitAsDefaultInstance();
  IMLiveSetRoomForbiddenStatusResp::default_instance_->InitAsDefaultInstance();
  IMLiveGetRoomForbiddenStatusReq::default_instance_->InitAsDefaultInstance();
  IMLiveGetRoomForbiddenStatusResp::default_instance_->InitAsDefaultInstance();
  IMLiveGetRoomInfoReq::default_instance_->InitAsDefaultInstance();
  IMLiveGetRoomInfoResp::default_instance_->InitAsDefaultInstance();
  IMLiveKickUser::default_instance_->InitAsDefaultInstance();
  IMLiveUserOfflineException::default_instance_->InitAsDefaultInstance();
  IMLiveRoomClose::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_IM_2eLive_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_IM_2eLive_2eproto_once_);
void protobuf_AddDesc_IM_2eLive_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_IM_2eLive_2eproto_once_,
                 &protobuf_AddDesc_IM_2eLive_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_IM_2eLive_2eproto {
  StaticDescriptorInitializer_IM_2eLive_2eproto() {
    protobuf_AddDesc_IM_2eLive_2eproto();
  }
} static_descriptor_initializer_IM_2eLive_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int IMLiveLoginRoomReq::kUserImIdFieldNumber;
const int IMLiveLoginRoomReq::kLiveIdFieldNumber;
const int IMLiveLoginRoomReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMLiveLoginRoomReq::IMLiveLoginRoomReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Live.IMLiveLoginRoomReq)
}

void IMLiveLoginRoomReq::InitAsDefaultInstance() {
}

IMLiveLoginRoomReq::IMLiveLoginRoomReq(const IMLiveLoginRoomReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Live.IMLiveLoginRoomReq)
}

void IMLiveLoginRoomReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  live_id_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMLiveLoginRoomReq::~IMLiveLoginRoomReq() {
  // @@protoc_insertion_point(destructor:IM.Live.IMLiveLoginRoomReq)
  SharedDtor();
}

void IMLiveLoginRoomReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMLiveLoginRoomReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMLiveLoginRoomReq& IMLiveLoginRoomReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eLive_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eLive_2eproto();
#endif
  return *default_instance_;
}

IMLiveLoginRoomReq* IMLiveLoginRoomReq::default_instance_ = NULL;

IMLiveLoginRoomReq* IMLiveLoginRoomReq::New() const {
  return new IMLiveLoginRoomReq;
}

void IMLiveLoginRoomReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMLiveLoginRoomReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(user_im_id_, live_id_);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMLiveLoginRoomReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Live.IMLiveLoginRoomReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_live_id;
        break;
      }

      // required uint32 live_id = 2;
      case 2: {
        if (tag == 16) {
         parse_live_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &live_id_)));
          set_has_live_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Live.IMLiveLoginRoomReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Live.IMLiveLoginRoomReq)
  return false;
#undef DO_
}

void IMLiveLoginRoomReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Live.IMLiveLoginRoomReq)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // required uint32 live_id = 2;
  if (has_live_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->live_id(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Live.IMLiveLoginRoomReq)
}

int IMLiveLoginRoomReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required uint32 live_id = 2;
    if (has_live_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->live_id());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMLiveLoginRoomReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMLiveLoginRoomReq*>(&from));
}

void IMLiveLoginRoomReq::MergeFrom(const IMLiveLoginRoomReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_live_id()) {
      set_live_id(from.live_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMLiveLoginRoomReq::CopyFrom(const IMLiveLoginRoomReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMLiveLoginRoomReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMLiveLoginRoomReq::Swap(IMLiveLoginRoomReq* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    std::swap(live_id_, other->live_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMLiveLoginRoomReq::GetTypeName() const {
  return "IM.Live.IMLiveLoginRoomReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMLiveLoginRoomResp::kUserImIdFieldNumber;
const int IMLiveLoginRoomResp::kLiveIdFieldNumber;
const int IMLiveLoginRoomResp::kRoomCntFieldNumber;
const int IMLiveLoginRoomResp::kMemberListFieldNumber;
const int IMLiveLoginRoomResp::kResultFieldNumber;
const int IMLiveLoginRoomResp::kUserNameFieldNumber;
const int IMLiveLoginRoomResp::kUserPortraitFieldNumber;
const int IMLiveLoginRoomResp::kForbiddenStatusFieldNumber;
const int IMLiveLoginRoomResp::kLastLiveIdFieldNumber;
const int IMLiveLoginRoomResp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMLiveLoginRoomResp::IMLiveLoginRoomResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Live.IMLiveLoginRoomResp)
}

void IMLiveLoginRoomResp::InitAsDefaultInstance() {
}

IMLiveLoginRoomResp::IMLiveLoginRoomResp(const IMLiveLoginRoomResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Live.IMLiveLoginRoomResp)
}

void IMLiveLoginRoomResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  live_id_ = 0u;
  room_cnt_ = 0u;
  result_ = 0u;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  forbidden_status_ = 0u;
  last_live_id_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMLiveLoginRoomResp::~IMLiveLoginRoomResp() {
  // @@protoc_insertion_point(destructor:IM.Live.IMLiveLoginRoomResp)
  SharedDtor();
}

void IMLiveLoginRoomResp::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_portrait_;
  }
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMLiveLoginRoomResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMLiveLoginRoomResp& IMLiveLoginRoomResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eLive_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eLive_2eproto();
#endif
  return *default_instance_;
}

IMLiveLoginRoomResp* IMLiveLoginRoomResp::default_instance_ = NULL;

IMLiveLoginRoomResp* IMLiveLoginRoomResp::New() const {
  return new IMLiveLoginRoomResp;
}

void IMLiveLoginRoomResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMLiveLoginRoomResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 247) {
    ZR_(user_im_id_, live_id_);
    ZR_(room_cnt_, result_);
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_name_->clear();
      }
    }
    if (has_user_portrait()) {
      if (user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_portrait_->clear();
      }
    }
    forbidden_status_ = 0u;
  }
  if (_has_bits_[8 / 32] & 768) {
    last_live_id_ = 0u;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  member_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMLiveLoginRoomResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Live.IMLiveLoginRoomResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_live_id;
        break;
      }

      // required uint32 live_id = 2;
      case 2: {
        if (tag == 16) {
         parse_live_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &live_id_)));
          set_has_live_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_room_cnt;
        break;
      }

      // required uint32 room_cnt = 3;
      case 3: {
        if (tag == 24) {
         parse_room_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &room_cnt_)));
          set_has_room_cnt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_member_list;
        break;
      }

      // repeated uint32 member_list = 4;
      case 4: {
        if (tag == 32) {
         parse_member_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_member_list())));
        } else if (tag == 34) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_member_list())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_member_list;
        if (input->ExpectTag(40)) goto parse_result;
        break;
      }

      // required uint32 result = 5;
      case 5: {
        if (tag == 40) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_user_name;
        break;
      }

      // required string user_name = 6;
      case 6: {
        if (tag == 50) {
         parse_user_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_user_portrait;
        break;
      }

      // required string user_portrait = 7;
      case 7: {
        if (tag == 58) {
         parse_user_portrait:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_portrait()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_forbidden_status;
        break;
      }

      // required uint32 forbidden_status = 8;
      case 8: {
        if (tag == 64) {
         parse_forbidden_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &forbidden_status_)));
          set_has_forbidden_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_last_live_id;
        break;
      }

      // optional uint32 last_live_id = 9;
      case 9: {
        if (tag == 72) {
         parse_last_live_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &last_live_id_)));
          set_has_last_live_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Live.IMLiveLoginRoomResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Live.IMLiveLoginRoomResp)
  return false;
#undef DO_
}

void IMLiveLoginRoomResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Live.IMLiveLoginRoomResp)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // required uint32 live_id = 2;
  if (has_live_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->live_id(), output);
  }

  // required uint32 room_cnt = 3;
  if (has_room_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->room_cnt(), output);
  }

  // repeated uint32 member_list = 4;
  for (int i = 0; i < this->member_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->member_list(i), output);
  }

  // required uint32 result = 5;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->result(), output);
  }

  // required string user_name = 6;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->user_name(), output);
  }

  // required string user_portrait = 7;
  if (has_user_portrait()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->user_portrait(), output);
  }

  // required uint32 forbidden_status = 8;
  if (has_forbidden_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->forbidden_status(), output);
  }

  // optional uint32 last_live_id = 9;
  if (has_last_live_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->last_live_id(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Live.IMLiveLoginRoomResp)
}

int IMLiveLoginRoomResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required uint32 live_id = 2;
    if (has_live_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->live_id());
    }

    // required uint32 room_cnt = 3;
    if (has_room_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->room_cnt());
    }

    // required uint32 result = 5;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

    // required string user_name = 6;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

    // required string user_portrait = 7;
    if (has_user_portrait()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_portrait());
    }

    // required uint32 forbidden_status = 8;
    if (has_forbidden_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->forbidden_status());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 last_live_id = 9;
    if (has_last_live_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->last_live_id());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated uint32 member_list = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->member_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->member_list(i));
    }
    total_size += 1 * this->member_list_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMLiveLoginRoomResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMLiveLoginRoomResp*>(&from));
}

void IMLiveLoginRoomResp::MergeFrom(const IMLiveLoginRoomResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  member_list_.MergeFrom(from.member_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_live_id()) {
      set_live_id(from.live_id());
    }
    if (from.has_room_cnt()) {
      set_room_cnt(from.room_cnt());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_user_portrait()) {
      set_user_portrait(from.user_portrait());
    }
    if (from.has_forbidden_status()) {
      set_forbidden_status(from.forbidden_status());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_last_live_id()) {
      set_last_live_id(from.last_live_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMLiveLoginRoomResp::CopyFrom(const IMLiveLoginRoomResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMLiveLoginRoomResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000f7) != 0x000000f7) return false;

  return true;
}

void IMLiveLoginRoomResp::Swap(IMLiveLoginRoomResp* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    std::swap(live_id_, other->live_id_);
    std::swap(room_cnt_, other->room_cnt_);
    member_list_.Swap(&other->member_list_);
    std::swap(result_, other->result_);
    std::swap(user_name_, other->user_name_);
    std::swap(user_portrait_, other->user_portrait_);
    std::swap(forbidden_status_, other->forbidden_status_);
    std::swap(last_live_id_, other->last_live_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMLiveLoginRoomResp::GetTypeName() const {
  return "IM.Live.IMLiveLoginRoomResp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMLiveLogoutRoomReq::kUserImIdFieldNumber;
const int IMLiveLogoutRoomReq::kLiveIdFieldNumber;
const int IMLiveLogoutRoomReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMLiveLogoutRoomReq::IMLiveLogoutRoomReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Live.IMLiveLogoutRoomReq)
}

void IMLiveLogoutRoomReq::InitAsDefaultInstance() {
}

IMLiveLogoutRoomReq::IMLiveLogoutRoomReq(const IMLiveLogoutRoomReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Live.IMLiveLogoutRoomReq)
}

void IMLiveLogoutRoomReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  live_id_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMLiveLogoutRoomReq::~IMLiveLogoutRoomReq() {
  // @@protoc_insertion_point(destructor:IM.Live.IMLiveLogoutRoomReq)
  SharedDtor();
}

void IMLiveLogoutRoomReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMLiveLogoutRoomReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMLiveLogoutRoomReq& IMLiveLogoutRoomReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eLive_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eLive_2eproto();
#endif
  return *default_instance_;
}

IMLiveLogoutRoomReq* IMLiveLogoutRoomReq::default_instance_ = NULL;

IMLiveLogoutRoomReq* IMLiveLogoutRoomReq::New() const {
  return new IMLiveLogoutRoomReq;
}

void IMLiveLogoutRoomReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMLiveLogoutRoomReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(user_im_id_, live_id_);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMLiveLogoutRoomReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Live.IMLiveLogoutRoomReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_live_id;
        break;
      }

      // required uint32 live_id = 2;
      case 2: {
        if (tag == 16) {
         parse_live_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &live_id_)));
          set_has_live_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Live.IMLiveLogoutRoomReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Live.IMLiveLogoutRoomReq)
  return false;
#undef DO_
}

void IMLiveLogoutRoomReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Live.IMLiveLogoutRoomReq)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // required uint32 live_id = 2;
  if (has_live_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->live_id(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Live.IMLiveLogoutRoomReq)
}

int IMLiveLogoutRoomReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required uint32 live_id = 2;
    if (has_live_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->live_id());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMLiveLogoutRoomReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMLiveLogoutRoomReq*>(&from));
}

void IMLiveLogoutRoomReq::MergeFrom(const IMLiveLogoutRoomReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_live_id()) {
      set_live_id(from.live_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMLiveLogoutRoomReq::CopyFrom(const IMLiveLogoutRoomReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMLiveLogoutRoomReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMLiveLogoutRoomReq::Swap(IMLiveLogoutRoomReq* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    std::swap(live_id_, other->live_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMLiveLogoutRoomReq::GetTypeName() const {
  return "IM.Live.IMLiveLogoutRoomReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMLiveLogoutRoomResp::kUserImIdFieldNumber;
const int IMLiveLogoutRoomResp::kLiveIdFieldNumber;
const int IMLiveLogoutRoomResp::kRoomCntFieldNumber;
const int IMLiveLogoutRoomResp::kMemberListFieldNumber;
const int IMLiveLogoutRoomResp::kResultFieldNumber;
const int IMLiveLogoutRoomResp::kUserNameFieldNumber;
const int IMLiveLogoutRoomResp::kUserPortraitFieldNumber;
const int IMLiveLogoutRoomResp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMLiveLogoutRoomResp::IMLiveLogoutRoomResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Live.IMLiveLogoutRoomResp)
}

void IMLiveLogoutRoomResp::InitAsDefaultInstance() {
}

IMLiveLogoutRoomResp::IMLiveLogoutRoomResp(const IMLiveLogoutRoomResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Live.IMLiveLogoutRoomResp)
}

void IMLiveLogoutRoomResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  live_id_ = 0u;
  room_cnt_ = 0u;
  result_ = 0u;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMLiveLogoutRoomResp::~IMLiveLogoutRoomResp() {
  // @@protoc_insertion_point(destructor:IM.Live.IMLiveLogoutRoomResp)
  SharedDtor();
}

void IMLiveLogoutRoomResp::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_portrait_;
  }
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMLiveLogoutRoomResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMLiveLogoutRoomResp& IMLiveLogoutRoomResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eLive_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eLive_2eproto();
#endif
  return *default_instance_;
}

IMLiveLogoutRoomResp* IMLiveLogoutRoomResp::default_instance_ = NULL;

IMLiveLogoutRoomResp* IMLiveLogoutRoomResp::New() const {
  return new IMLiveLogoutRoomResp;
}

void IMLiveLogoutRoomResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMLiveLogoutRoomResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 247) {
    ZR_(user_im_id_, live_id_);
    ZR_(room_cnt_, result_);
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_name_->clear();
      }
    }
    if (has_user_portrait()) {
      if (user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_portrait_->clear();
      }
    }
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  member_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMLiveLogoutRoomResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Live.IMLiveLogoutRoomResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_live_id;
        break;
      }

      // required uint32 live_id = 2;
      case 2: {
        if (tag == 16) {
         parse_live_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &live_id_)));
          set_has_live_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_room_cnt;
        break;
      }

      // required uint32 room_cnt = 3;
      case 3: {
        if (tag == 24) {
         parse_room_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &room_cnt_)));
          set_has_room_cnt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_member_list;
        break;
      }

      // repeated uint32 member_list = 4;
      case 4: {
        if (tag == 32) {
         parse_member_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_member_list())));
        } else if (tag == 34) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_member_list())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_member_list;
        if (input->ExpectTag(40)) goto parse_result;
        break;
      }

      // required uint32 result = 5;
      case 5: {
        if (tag == 40) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_user_name;
        break;
      }

      // required string user_name = 6;
      case 6: {
        if (tag == 50) {
         parse_user_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_user_portrait;
        break;
      }

      // required string user_portrait = 7;
      case 7: {
        if (tag == 58) {
         parse_user_portrait:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_portrait()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Live.IMLiveLogoutRoomResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Live.IMLiveLogoutRoomResp)
  return false;
#undef DO_
}

void IMLiveLogoutRoomResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Live.IMLiveLogoutRoomResp)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // required uint32 live_id = 2;
  if (has_live_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->live_id(), output);
  }

  // required uint32 room_cnt = 3;
  if (has_room_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->room_cnt(), output);
  }

  // repeated uint32 member_list = 4;
  for (int i = 0; i < this->member_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->member_list(i), output);
  }

  // required uint32 result = 5;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->result(), output);
  }

  // required string user_name = 6;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->user_name(), output);
  }

  // required string user_portrait = 7;
  if (has_user_portrait()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->user_portrait(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Live.IMLiveLogoutRoomResp)
}

int IMLiveLogoutRoomResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required uint32 live_id = 2;
    if (has_live_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->live_id());
    }

    // required uint32 room_cnt = 3;
    if (has_room_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->room_cnt());
    }

    // required uint32 result = 5;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

    // required string user_name = 6;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

    // required string user_portrait = 7;
    if (has_user_portrait()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_portrait());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated uint32 member_list = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->member_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->member_list(i));
    }
    total_size += 1 * this->member_list_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMLiveLogoutRoomResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMLiveLogoutRoomResp*>(&from));
}

void IMLiveLogoutRoomResp::MergeFrom(const IMLiveLogoutRoomResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  member_list_.MergeFrom(from.member_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_live_id()) {
      set_live_id(from.live_id());
    }
    if (from.has_room_cnt()) {
      set_room_cnt(from.room_cnt());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_user_portrait()) {
      set_user_portrait(from.user_portrait());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMLiveLogoutRoomResp::CopyFrom(const IMLiveLogoutRoomResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMLiveLogoutRoomResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000077) != 0x00000077) return false;

  return true;
}

void IMLiveLogoutRoomResp::Swap(IMLiveLogoutRoomResp* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    std::swap(live_id_, other->live_id_);
    std::swap(room_cnt_, other->room_cnt_);
    member_list_.Swap(&other->member_list_);
    std::swap(result_, other->result_);
    std::swap(user_name_, other->user_name_);
    std::swap(user_portrait_, other->user_portrait_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMLiveLogoutRoomResp::GetTypeName() const {
  return "IM.Live.IMLiveLogoutRoomResp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMLiveData::kFromUserIdFieldNumber;
const int IMLiveData::kToSessionIdFieldNumber;
const int IMLiveData::kFromUserNameFieldNumber;
const int IMLiveData::kFromUserPortraitFieldNumber;
const int IMLiveData::kMsgDataFieldNumber;
const int IMLiveData::kMsgTypeFieldNumber;
const int IMLiveData::kCreateTimeFieldNumber;
const int IMLiveData::kMemberListFieldNumber;
const int IMLiveData::kResultFieldNumber;
const int IMLiveData::kRecordIdFieldNumber;
const int IMLiveData::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMLiveData::IMLiveData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Live.IMLiveData)
}

void IMLiveData::InitAsDefaultInstance() {
}

IMLiveData::IMLiveData(const IMLiveData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Live.IMLiveData)
}

void IMLiveData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  from_user_id_ = 0u;
  to_session_id_ = 0u;
  from_user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  from_user_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  msg_type_ = 0u;
  create_time_ = 0u;
  result_ = 0u;
  record_id_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMLiveData::~IMLiveData() {
  // @@protoc_insertion_point(destructor:IM.Live.IMLiveData)
  SharedDtor();
}

void IMLiveData::SharedDtor() {
  if (from_user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete from_user_name_;
  }
  if (from_user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete from_user_portrait_;
  }
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_data_;
  }
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMLiveData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMLiveData& IMLiveData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eLive_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eLive_2eproto();
#endif
  return *default_instance_;
}

IMLiveData* IMLiveData::default_instance_ = NULL;

IMLiveData* IMLiveData::New() const {
  return new IMLiveData;
}

void IMLiveData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMLiveData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(from_user_id_, to_session_id_);
    ZR_(msg_type_, create_time_);
    if (has_from_user_name()) {
      if (from_user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        from_user_name_->clear();
      }
    }
    if (has_from_user_portrait()) {
      if (from_user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        from_user_portrait_->clear();
      }
    }
    if (has_msg_data()) {
      if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        msg_data_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & 1792) {
    ZR_(result_, record_id_);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  member_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMLiveData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Live.IMLiveData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_to_session_id;
        break;
      }

      // required uint32 to_session_id = 2;
      case 2: {
        if (tag == 16) {
         parse_to_session_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_session_id_)));
          set_has_to_session_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_from_user_name;
        break;
      }

      // optional string from_user_name = 3;
      case 3: {
        if (tag == 26) {
         parse_from_user_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_from_user_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_from_user_portrait;
        break;
      }

      // optional string from_user_portrait = 4;
      case 4: {
        if (tag == 34) {
         parse_from_user_portrait:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_from_user_portrait()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_msg_data;
        break;
      }

      // required bytes msg_data = 5;
      case 5: {
        if (tag == 42) {
         parse_msg_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_msg_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_msg_type;
        break;
      }

      // required uint32 msg_type = 6;
      case 6: {
        if (tag == 48) {
         parse_msg_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msg_type_)));
          set_has_msg_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_create_time;
        break;
      }

      // required uint32 create_time = 7;
      case 7: {
        if (tag == 56) {
         parse_create_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &create_time_)));
          set_has_create_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_member_list;
        break;
      }

      // repeated uint32 member_list = 8;
      case 8: {
        if (tag == 64) {
         parse_member_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 64, input, this->mutable_member_list())));
        } else if (tag == 66) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_member_list())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_member_list;
        if (input->ExpectTag(72)) goto parse_result;
        break;
      }

      // required uint32 result = 9;
      case 9: {
        if (tag == 72) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_record_id;
        break;
      }

      // optional uint32 record_id = 10;
      case 10: {
        if (tag == 80) {
         parse_record_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &record_id_)));
          set_has_record_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Live.IMLiveData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Live.IMLiveData)
  return false;
#undef DO_
}

void IMLiveData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Live.IMLiveData)
  // required uint32 from_user_id = 1;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_user_id(), output);
  }

  // required uint32 to_session_id = 2;
  if (has_to_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->to_session_id(), output);
  }

  // optional string from_user_name = 3;
  if (has_from_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->from_user_name(), output);
  }

  // optional string from_user_portrait = 4;
  if (has_from_user_portrait()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->from_user_portrait(), output);
  }

  // required bytes msg_data = 5;
  if (has_msg_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->msg_data(), output);
  }

  // required uint32 msg_type = 6;
  if (has_msg_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->msg_type(), output);
  }

  // required uint32 create_time = 7;
  if (has_create_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->create_time(), output);
  }

  // repeated uint32 member_list = 8;
  for (int i = 0; i < this->member_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      8, this->member_list(i), output);
  }

  // required uint32 result = 9;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->result(), output);
  }

  // optional uint32 record_id = 10;
  if (has_record_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->record_id(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Live.IMLiveData)
}

int IMLiveData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 from_user_id = 1;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }

    // required uint32 to_session_id = 2;
    if (has_to_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_session_id());
    }

    // optional string from_user_name = 3;
    if (has_from_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->from_user_name());
    }

    // optional string from_user_portrait = 4;
    if (has_from_user_portrait()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->from_user_portrait());
    }

    // required bytes msg_data = 5;
    if (has_msg_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->msg_data());
    }

    // required uint32 msg_type = 6;
    if (has_msg_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msg_type());
    }

    // required uint32 create_time = 7;
    if (has_create_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->create_time());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 result = 9;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

    // optional uint32 record_id = 10;
    if (has_record_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->record_id());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated uint32 member_list = 8;
  {
    int data_size = 0;
    for (int i = 0; i < this->member_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->member_list(i));
    }
    total_size += 1 * this->member_list_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMLiveData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMLiveData*>(&from));
}

void IMLiveData::MergeFrom(const IMLiveData& from) {
  GOOGLE_CHECK_NE(&from, this);
  member_list_.MergeFrom(from.member_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_to_session_id()) {
      set_to_session_id(from.to_session_id());
    }
    if (from.has_from_user_name()) {
      set_from_user_name(from.from_user_name());
    }
    if (from.has_from_user_portrait()) {
      set_from_user_portrait(from.from_user_portrait());
    }
    if (from.has_msg_data()) {
      set_msg_data(from.msg_data());
    }
    if (from.has_msg_type()) {
      set_msg_type(from.msg_type());
    }
    if (from.has_create_time()) {
      set_create_time(from.create_time());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_record_id()) {
      set_record_id(from.record_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMLiveData::CopyFrom(const IMLiveData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMLiveData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000173) != 0x00000173) return false;

  return true;
}

void IMLiveData::Swap(IMLiveData* other) {
  if (other != this) {
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(to_session_id_, other->to_session_id_);
    std::swap(from_user_name_, other->from_user_name_);
    std::swap(from_user_portrait_, other->from_user_portrait_);
    std::swap(msg_data_, other->msg_data_);
    std::swap(msg_type_, other->msg_type_);
    std::swap(create_time_, other->create_time_);
    member_list_.Swap(&other->member_list_);
    std::swap(result_, other->result_);
    std::swap(record_id_, other->record_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMLiveData::GetTypeName() const {
  return "IM.Live.IMLiveData";
}


// ===================================================================

#ifndef _MSC_VER
const int IMLiveSetRoomForbiddenStatusReq::kUserImIdFieldNumber;
const int IMLiveSetRoomForbiddenStatusReq::kLiveIdFieldNumber;
const int IMLiveSetRoomForbiddenStatusReq::kStatusFieldNumber;
const int IMLiveSetRoomForbiddenStatusReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMLiveSetRoomForbiddenStatusReq::IMLiveSetRoomForbiddenStatusReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Live.IMLiveSetRoomForbiddenStatusReq)
}

void IMLiveSetRoomForbiddenStatusReq::InitAsDefaultInstance() {
}

IMLiveSetRoomForbiddenStatusReq::IMLiveSetRoomForbiddenStatusReq(const IMLiveSetRoomForbiddenStatusReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Live.IMLiveSetRoomForbiddenStatusReq)
}

void IMLiveSetRoomForbiddenStatusReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  live_id_ = 0u;
  status_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMLiveSetRoomForbiddenStatusReq::~IMLiveSetRoomForbiddenStatusReq() {
  // @@protoc_insertion_point(destructor:IM.Live.IMLiveSetRoomForbiddenStatusReq)
  SharedDtor();
}

void IMLiveSetRoomForbiddenStatusReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMLiveSetRoomForbiddenStatusReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMLiveSetRoomForbiddenStatusReq& IMLiveSetRoomForbiddenStatusReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eLive_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eLive_2eproto();
#endif
  return *default_instance_;
}

IMLiveSetRoomForbiddenStatusReq* IMLiveSetRoomForbiddenStatusReq::default_instance_ = NULL;

IMLiveSetRoomForbiddenStatusReq* IMLiveSetRoomForbiddenStatusReq::New() const {
  return new IMLiveSetRoomForbiddenStatusReq;
}

void IMLiveSetRoomForbiddenStatusReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMLiveSetRoomForbiddenStatusReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(user_im_id_, live_id_);
    status_ = 0u;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMLiveSetRoomForbiddenStatusReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Live.IMLiveSetRoomForbiddenStatusReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_live_id;
        break;
      }

      // required uint32 live_id = 2;
      case 2: {
        if (tag == 16) {
         parse_live_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &live_id_)));
          set_has_live_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_status;
        break;
      }

      // required uint32 status = 3;
      case 3: {
        if (tag == 24) {
         parse_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Live.IMLiveSetRoomForbiddenStatusReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Live.IMLiveSetRoomForbiddenStatusReq)
  return false;
#undef DO_
}

void IMLiveSetRoomForbiddenStatusReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Live.IMLiveSetRoomForbiddenStatusReq)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // required uint32 live_id = 2;
  if (has_live_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->live_id(), output);
  }

  // required uint32 status = 3;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->status(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Live.IMLiveSetRoomForbiddenStatusReq)
}

int IMLiveSetRoomForbiddenStatusReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required uint32 live_id = 2;
    if (has_live_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->live_id());
    }

    // required uint32 status = 3;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->status());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMLiveSetRoomForbiddenStatusReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMLiveSetRoomForbiddenStatusReq*>(&from));
}

void IMLiveSetRoomForbiddenStatusReq::MergeFrom(const IMLiveSetRoomForbiddenStatusReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_live_id()) {
      set_live_id(from.live_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMLiveSetRoomForbiddenStatusReq::CopyFrom(const IMLiveSetRoomForbiddenStatusReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMLiveSetRoomForbiddenStatusReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void IMLiveSetRoomForbiddenStatusReq::Swap(IMLiveSetRoomForbiddenStatusReq* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    std::swap(live_id_, other->live_id_);
    std::swap(status_, other->status_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMLiveSetRoomForbiddenStatusReq::GetTypeName() const {
  return "IM.Live.IMLiveSetRoomForbiddenStatusReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMLiveSetRoomForbiddenStatusResp::kUserImIdFieldNumber;
const int IMLiveSetRoomForbiddenStatusResp::kLiveIdFieldNumber;
const int IMLiveSetRoomForbiddenStatusResp::kStatusFieldNumber;
const int IMLiveSetRoomForbiddenStatusResp::kMemberListFieldNumber;
const int IMLiveSetRoomForbiddenStatusResp::kResultFieldNumber;
const int IMLiveSetRoomForbiddenStatusResp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMLiveSetRoomForbiddenStatusResp::IMLiveSetRoomForbiddenStatusResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Live.IMLiveSetRoomForbiddenStatusResp)
}

void IMLiveSetRoomForbiddenStatusResp::InitAsDefaultInstance() {
}

IMLiveSetRoomForbiddenStatusResp::IMLiveSetRoomForbiddenStatusResp(const IMLiveSetRoomForbiddenStatusResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Live.IMLiveSetRoomForbiddenStatusResp)
}

void IMLiveSetRoomForbiddenStatusResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  live_id_ = 0u;
  status_ = 0u;
  result_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMLiveSetRoomForbiddenStatusResp::~IMLiveSetRoomForbiddenStatusResp() {
  // @@protoc_insertion_point(destructor:IM.Live.IMLiveSetRoomForbiddenStatusResp)
  SharedDtor();
}

void IMLiveSetRoomForbiddenStatusResp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMLiveSetRoomForbiddenStatusResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMLiveSetRoomForbiddenStatusResp& IMLiveSetRoomForbiddenStatusResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eLive_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eLive_2eproto();
#endif
  return *default_instance_;
}

IMLiveSetRoomForbiddenStatusResp* IMLiveSetRoomForbiddenStatusResp::default_instance_ = NULL;

IMLiveSetRoomForbiddenStatusResp* IMLiveSetRoomForbiddenStatusResp::New() const {
  return new IMLiveSetRoomForbiddenStatusResp;
}

void IMLiveSetRoomForbiddenStatusResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMLiveSetRoomForbiddenStatusResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 55) {
    ZR_(user_im_id_, live_id_);
    ZR_(status_, result_);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  member_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMLiveSetRoomForbiddenStatusResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Live.IMLiveSetRoomForbiddenStatusResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_live_id;
        break;
      }

      // required uint32 live_id = 2;
      case 2: {
        if (tag == 16) {
         parse_live_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &live_id_)));
          set_has_live_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_status;
        break;
      }

      // required uint32 status = 3;
      case 3: {
        if (tag == 24) {
         parse_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_member_list;
        break;
      }

      // repeated uint32 member_list = 4;
      case 4: {
        if (tag == 32) {
         parse_member_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_member_list())));
        } else if (tag == 34) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_member_list())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_member_list;
        if (input->ExpectTag(40)) goto parse_result;
        break;
      }

      // required uint32 result = 5;
      case 5: {
        if (tag == 40) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Live.IMLiveSetRoomForbiddenStatusResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Live.IMLiveSetRoomForbiddenStatusResp)
  return false;
#undef DO_
}

void IMLiveSetRoomForbiddenStatusResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Live.IMLiveSetRoomForbiddenStatusResp)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // required uint32 live_id = 2;
  if (has_live_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->live_id(), output);
  }

  // required uint32 status = 3;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->status(), output);
  }

  // repeated uint32 member_list = 4;
  for (int i = 0; i < this->member_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->member_list(i), output);
  }

  // required uint32 result = 5;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->result(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Live.IMLiveSetRoomForbiddenStatusResp)
}

int IMLiveSetRoomForbiddenStatusResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required uint32 live_id = 2;
    if (has_live_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->live_id());
    }

    // required uint32 status = 3;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->status());
    }

    // required uint32 result = 5;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated uint32 member_list = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->member_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->member_list(i));
    }
    total_size += 1 * this->member_list_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMLiveSetRoomForbiddenStatusResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMLiveSetRoomForbiddenStatusResp*>(&from));
}

void IMLiveSetRoomForbiddenStatusResp::MergeFrom(const IMLiveSetRoomForbiddenStatusResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  member_list_.MergeFrom(from.member_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_live_id()) {
      set_live_id(from.live_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMLiveSetRoomForbiddenStatusResp::CopyFrom(const IMLiveSetRoomForbiddenStatusResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMLiveSetRoomForbiddenStatusResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000017) != 0x00000017) return false;

  return true;
}

void IMLiveSetRoomForbiddenStatusResp::Swap(IMLiveSetRoomForbiddenStatusResp* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    std::swap(live_id_, other->live_id_);
    std::swap(status_, other->status_);
    member_list_.Swap(&other->member_list_);
    std::swap(result_, other->result_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMLiveSetRoomForbiddenStatusResp::GetTypeName() const {
  return "IM.Live.IMLiveSetRoomForbiddenStatusResp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMLiveGetRoomForbiddenStatusReq::kUserImIdFieldNumber;
const int IMLiveGetRoomForbiddenStatusReq::kLiveIdFieldNumber;
const int IMLiveGetRoomForbiddenStatusReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMLiveGetRoomForbiddenStatusReq::IMLiveGetRoomForbiddenStatusReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Live.IMLiveGetRoomForbiddenStatusReq)
}

void IMLiveGetRoomForbiddenStatusReq::InitAsDefaultInstance() {
}

IMLiveGetRoomForbiddenStatusReq::IMLiveGetRoomForbiddenStatusReq(const IMLiveGetRoomForbiddenStatusReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Live.IMLiveGetRoomForbiddenStatusReq)
}

void IMLiveGetRoomForbiddenStatusReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  live_id_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMLiveGetRoomForbiddenStatusReq::~IMLiveGetRoomForbiddenStatusReq() {
  // @@protoc_insertion_point(destructor:IM.Live.IMLiveGetRoomForbiddenStatusReq)
  SharedDtor();
}

void IMLiveGetRoomForbiddenStatusReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMLiveGetRoomForbiddenStatusReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMLiveGetRoomForbiddenStatusReq& IMLiveGetRoomForbiddenStatusReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eLive_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eLive_2eproto();
#endif
  return *default_instance_;
}

IMLiveGetRoomForbiddenStatusReq* IMLiveGetRoomForbiddenStatusReq::default_instance_ = NULL;

IMLiveGetRoomForbiddenStatusReq* IMLiveGetRoomForbiddenStatusReq::New() const {
  return new IMLiveGetRoomForbiddenStatusReq;
}

void IMLiveGetRoomForbiddenStatusReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMLiveGetRoomForbiddenStatusReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(user_im_id_, live_id_);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMLiveGetRoomForbiddenStatusReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Live.IMLiveGetRoomForbiddenStatusReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_live_id;
        break;
      }

      // required uint32 live_id = 2;
      case 2: {
        if (tag == 16) {
         parse_live_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &live_id_)));
          set_has_live_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Live.IMLiveGetRoomForbiddenStatusReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Live.IMLiveGetRoomForbiddenStatusReq)
  return false;
#undef DO_
}

void IMLiveGetRoomForbiddenStatusReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Live.IMLiveGetRoomForbiddenStatusReq)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // required uint32 live_id = 2;
  if (has_live_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->live_id(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Live.IMLiveGetRoomForbiddenStatusReq)
}

int IMLiveGetRoomForbiddenStatusReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required uint32 live_id = 2;
    if (has_live_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->live_id());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMLiveGetRoomForbiddenStatusReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMLiveGetRoomForbiddenStatusReq*>(&from));
}

void IMLiveGetRoomForbiddenStatusReq::MergeFrom(const IMLiveGetRoomForbiddenStatusReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_live_id()) {
      set_live_id(from.live_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMLiveGetRoomForbiddenStatusReq::CopyFrom(const IMLiveGetRoomForbiddenStatusReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMLiveGetRoomForbiddenStatusReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMLiveGetRoomForbiddenStatusReq::Swap(IMLiveGetRoomForbiddenStatusReq* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    std::swap(live_id_, other->live_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMLiveGetRoomForbiddenStatusReq::GetTypeName() const {
  return "IM.Live.IMLiveGetRoomForbiddenStatusReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMLiveGetRoomForbiddenStatusResp::kUserImIdFieldNumber;
const int IMLiveGetRoomForbiddenStatusResp::kLiveIdFieldNumber;
const int IMLiveGetRoomForbiddenStatusResp::kStatusFieldNumber;
const int IMLiveGetRoomForbiddenStatusResp::kResultFieldNumber;
const int IMLiveGetRoomForbiddenStatusResp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMLiveGetRoomForbiddenStatusResp::IMLiveGetRoomForbiddenStatusResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Live.IMLiveGetRoomForbiddenStatusResp)
}

void IMLiveGetRoomForbiddenStatusResp::InitAsDefaultInstance() {
}

IMLiveGetRoomForbiddenStatusResp::IMLiveGetRoomForbiddenStatusResp(const IMLiveGetRoomForbiddenStatusResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Live.IMLiveGetRoomForbiddenStatusResp)
}

void IMLiveGetRoomForbiddenStatusResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  live_id_ = 0u;
  status_ = 0u;
  result_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMLiveGetRoomForbiddenStatusResp::~IMLiveGetRoomForbiddenStatusResp() {
  // @@protoc_insertion_point(destructor:IM.Live.IMLiveGetRoomForbiddenStatusResp)
  SharedDtor();
}

void IMLiveGetRoomForbiddenStatusResp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMLiveGetRoomForbiddenStatusResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMLiveGetRoomForbiddenStatusResp& IMLiveGetRoomForbiddenStatusResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eLive_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eLive_2eproto();
#endif
  return *default_instance_;
}

IMLiveGetRoomForbiddenStatusResp* IMLiveGetRoomForbiddenStatusResp::default_instance_ = NULL;

IMLiveGetRoomForbiddenStatusResp* IMLiveGetRoomForbiddenStatusResp::New() const {
  return new IMLiveGetRoomForbiddenStatusResp;
}

void IMLiveGetRoomForbiddenStatusResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMLiveGetRoomForbiddenStatusResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(user_im_id_, result_);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMLiveGetRoomForbiddenStatusResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Live.IMLiveGetRoomForbiddenStatusResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_live_id;
        break;
      }

      // required uint32 live_id = 2;
      case 2: {
        if (tag == 16) {
         parse_live_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &live_id_)));
          set_has_live_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_status;
        break;
      }

      // required uint32 status = 3;
      case 3: {
        if (tag == 24) {
         parse_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_result;
        break;
      }

      // required uint32 result = 4;
      case 4: {
        if (tag == 32) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Live.IMLiveGetRoomForbiddenStatusResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Live.IMLiveGetRoomForbiddenStatusResp)
  return false;
#undef DO_
}

void IMLiveGetRoomForbiddenStatusResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Live.IMLiveGetRoomForbiddenStatusResp)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // required uint32 live_id = 2;
  if (has_live_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->live_id(), output);
  }

  // required uint32 status = 3;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->status(), output);
  }

  // required uint32 result = 4;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->result(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Live.IMLiveGetRoomForbiddenStatusResp)
}

int IMLiveGetRoomForbiddenStatusResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required uint32 live_id = 2;
    if (has_live_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->live_id());
    }

    // required uint32 status = 3;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->status());
    }

    // required uint32 result = 4;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMLiveGetRoomForbiddenStatusResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMLiveGetRoomForbiddenStatusResp*>(&from));
}

void IMLiveGetRoomForbiddenStatusResp::MergeFrom(const IMLiveGetRoomForbiddenStatusResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_live_id()) {
      set_live_id(from.live_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMLiveGetRoomForbiddenStatusResp::CopyFrom(const IMLiveGetRoomForbiddenStatusResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMLiveGetRoomForbiddenStatusResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void IMLiveGetRoomForbiddenStatusResp::Swap(IMLiveGetRoomForbiddenStatusResp* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    std::swap(live_id_, other->live_id_);
    std::swap(status_, other->status_);
    std::swap(result_, other->result_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMLiveGetRoomForbiddenStatusResp::GetTypeName() const {
  return "IM.Live.IMLiveGetRoomForbiddenStatusResp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMLiveGetRoomInfoReq::kUserImIdFieldNumber;
const int IMLiveGetRoomInfoReq::kLiveIdFieldNumber;
const int IMLiveGetRoomInfoReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMLiveGetRoomInfoReq::IMLiveGetRoomInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Live.IMLiveGetRoomInfoReq)
}

void IMLiveGetRoomInfoReq::InitAsDefaultInstance() {
}

IMLiveGetRoomInfoReq::IMLiveGetRoomInfoReq(const IMLiveGetRoomInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Live.IMLiveGetRoomInfoReq)
}

void IMLiveGetRoomInfoReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  live_id_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMLiveGetRoomInfoReq::~IMLiveGetRoomInfoReq() {
  // @@protoc_insertion_point(destructor:IM.Live.IMLiveGetRoomInfoReq)
  SharedDtor();
}

void IMLiveGetRoomInfoReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMLiveGetRoomInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMLiveGetRoomInfoReq& IMLiveGetRoomInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eLive_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eLive_2eproto();
#endif
  return *default_instance_;
}

IMLiveGetRoomInfoReq* IMLiveGetRoomInfoReq::default_instance_ = NULL;

IMLiveGetRoomInfoReq* IMLiveGetRoomInfoReq::New() const {
  return new IMLiveGetRoomInfoReq;
}

void IMLiveGetRoomInfoReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMLiveGetRoomInfoReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(user_im_id_, live_id_);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMLiveGetRoomInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Live.IMLiveGetRoomInfoReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_live_id;
        break;
      }

      // required uint32 live_id = 2;
      case 2: {
        if (tag == 16) {
         parse_live_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &live_id_)));
          set_has_live_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Live.IMLiveGetRoomInfoReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Live.IMLiveGetRoomInfoReq)
  return false;
#undef DO_
}

void IMLiveGetRoomInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Live.IMLiveGetRoomInfoReq)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // required uint32 live_id = 2;
  if (has_live_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->live_id(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Live.IMLiveGetRoomInfoReq)
}

int IMLiveGetRoomInfoReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required uint32 live_id = 2;
    if (has_live_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->live_id());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMLiveGetRoomInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMLiveGetRoomInfoReq*>(&from));
}

void IMLiveGetRoomInfoReq::MergeFrom(const IMLiveGetRoomInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_live_id()) {
      set_live_id(from.live_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMLiveGetRoomInfoReq::CopyFrom(const IMLiveGetRoomInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMLiveGetRoomInfoReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMLiveGetRoomInfoReq::Swap(IMLiveGetRoomInfoReq* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    std::swap(live_id_, other->live_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMLiveGetRoomInfoReq::GetTypeName() const {
  return "IM.Live.IMLiveGetRoomInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMLiveGetRoomInfoResp::kUserImIdFieldNumber;
const int IMLiveGetRoomInfoResp::kLiveIdFieldNumber;
const int IMLiveGetRoomInfoResp::kForbiddenStatusFieldNumber;
const int IMLiveGetRoomInfoResp::kRoomCntFieldNumber;
const int IMLiveGetRoomInfoResp::kMemberListFieldNumber;
const int IMLiveGetRoomInfoResp::kResultFieldNumber;
#endif  // !_MSC_VER

IMLiveGetRoomInfoResp::IMLiveGetRoomInfoResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Live.IMLiveGetRoomInfoResp)
}

void IMLiveGetRoomInfoResp::InitAsDefaultInstance() {
}

IMLiveGetRoomInfoResp::IMLiveGetRoomInfoResp(const IMLiveGetRoomInfoResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Live.IMLiveGetRoomInfoResp)
}

void IMLiveGetRoomInfoResp::SharedCtor() {
  _cached_size_ = 0;
  user_im_id_ = 0u;
  live_id_ = 0u;
  forbidden_status_ = 0u;
  room_cnt_ = 0u;
  result_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMLiveGetRoomInfoResp::~IMLiveGetRoomInfoResp() {
  // @@protoc_insertion_point(destructor:IM.Live.IMLiveGetRoomInfoResp)
  SharedDtor();
}

void IMLiveGetRoomInfoResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMLiveGetRoomInfoResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMLiveGetRoomInfoResp& IMLiveGetRoomInfoResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eLive_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eLive_2eproto();
#endif
  return *default_instance_;
}

IMLiveGetRoomInfoResp* IMLiveGetRoomInfoResp::default_instance_ = NULL;

IMLiveGetRoomInfoResp* IMLiveGetRoomInfoResp::New() const {
  return new IMLiveGetRoomInfoResp;
}

void IMLiveGetRoomInfoResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMLiveGetRoomInfoResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 47) {
    ZR_(user_im_id_, room_cnt_);
    result_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  member_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMLiveGetRoomInfoResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Live.IMLiveGetRoomInfoResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_live_id;
        break;
      }

      // required uint32 live_id = 2;
      case 2: {
        if (tag == 16) {
         parse_live_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &live_id_)));
          set_has_live_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_forbidden_status;
        break;
      }

      // required uint32 forbidden_status = 3;
      case 3: {
        if (tag == 24) {
         parse_forbidden_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &forbidden_status_)));
          set_has_forbidden_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_room_cnt;
        break;
      }

      // required uint32 room_cnt = 4;
      case 4: {
        if (tag == 32) {
         parse_room_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &room_cnt_)));
          set_has_room_cnt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_member_list;
        break;
      }

      // repeated uint32 member_list = 5;
      case 5: {
        if (tag == 40) {
         parse_member_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 40, input, this->mutable_member_list())));
        } else if (tag == 42) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_member_list())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_member_list;
        if (input->ExpectTag(48)) goto parse_result;
        break;
      }

      // required uint32 result = 6;
      case 6: {
        if (tag == 48) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Live.IMLiveGetRoomInfoResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Live.IMLiveGetRoomInfoResp)
  return false;
#undef DO_
}

void IMLiveGetRoomInfoResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Live.IMLiveGetRoomInfoResp)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // required uint32 live_id = 2;
  if (has_live_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->live_id(), output);
  }

  // required uint32 forbidden_status = 3;
  if (has_forbidden_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->forbidden_status(), output);
  }

  // required uint32 room_cnt = 4;
  if (has_room_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->room_cnt(), output);
  }

  // repeated uint32 member_list = 5;
  for (int i = 0; i < this->member_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      5, this->member_list(i), output);
  }

  // required uint32 result = 6;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->result(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Live.IMLiveGetRoomInfoResp)
}

int IMLiveGetRoomInfoResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required uint32 live_id = 2;
    if (has_live_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->live_id());
    }

    // required uint32 forbidden_status = 3;
    if (has_forbidden_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->forbidden_status());
    }

    // required uint32 room_cnt = 4;
    if (has_room_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->room_cnt());
    }

    // required uint32 result = 6;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

  }
  // repeated uint32 member_list = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->member_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->member_list(i));
    }
    total_size += 1 * this->member_list_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMLiveGetRoomInfoResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMLiveGetRoomInfoResp*>(&from));
}

void IMLiveGetRoomInfoResp::MergeFrom(const IMLiveGetRoomInfoResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  member_list_.MergeFrom(from.member_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_live_id()) {
      set_live_id(from.live_id());
    }
    if (from.has_forbidden_status()) {
      set_forbidden_status(from.forbidden_status());
    }
    if (from.has_room_cnt()) {
      set_room_cnt(from.room_cnt());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMLiveGetRoomInfoResp::CopyFrom(const IMLiveGetRoomInfoResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMLiveGetRoomInfoResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000002f) != 0x0000002f) return false;

  return true;
}

void IMLiveGetRoomInfoResp::Swap(IMLiveGetRoomInfoResp* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    std::swap(live_id_, other->live_id_);
    std::swap(forbidden_status_, other->forbidden_status_);
    std::swap(room_cnt_, other->room_cnt_);
    member_list_.Swap(&other->member_list_);
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMLiveGetRoomInfoResp::GetTypeName() const {
  return "IM.Live.IMLiveGetRoomInfoResp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMLiveKickUser::kUserImIdFieldNumber;
const int IMLiveKickUser::kLiveIdFieldNumber;
const int IMLiveKickUser::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMLiveKickUser::IMLiveKickUser()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Live.IMLiveKickUser)
}

void IMLiveKickUser::InitAsDefaultInstance() {
}

IMLiveKickUser::IMLiveKickUser(const IMLiveKickUser& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Live.IMLiveKickUser)
}

void IMLiveKickUser::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  live_id_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMLiveKickUser::~IMLiveKickUser() {
  // @@protoc_insertion_point(destructor:IM.Live.IMLiveKickUser)
  SharedDtor();
}

void IMLiveKickUser::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMLiveKickUser::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMLiveKickUser& IMLiveKickUser::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eLive_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eLive_2eproto();
#endif
  return *default_instance_;
}

IMLiveKickUser* IMLiveKickUser::default_instance_ = NULL;

IMLiveKickUser* IMLiveKickUser::New() const {
  return new IMLiveKickUser;
}

void IMLiveKickUser::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMLiveKickUser*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(user_im_id_, live_id_);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMLiveKickUser::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Live.IMLiveKickUser)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_live_id;
        break;
      }

      // required uint32 live_id = 2;
      case 2: {
        if (tag == 16) {
         parse_live_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &live_id_)));
          set_has_live_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Live.IMLiveKickUser)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Live.IMLiveKickUser)
  return false;
#undef DO_
}

void IMLiveKickUser::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Live.IMLiveKickUser)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // required uint32 live_id = 2;
  if (has_live_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->live_id(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Live.IMLiveKickUser)
}

int IMLiveKickUser::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required uint32 live_id = 2;
    if (has_live_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->live_id());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMLiveKickUser::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMLiveKickUser*>(&from));
}

void IMLiveKickUser::MergeFrom(const IMLiveKickUser& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_live_id()) {
      set_live_id(from.live_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMLiveKickUser::CopyFrom(const IMLiveKickUser& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMLiveKickUser::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMLiveKickUser::Swap(IMLiveKickUser* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    std::swap(live_id_, other->live_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMLiveKickUser::GetTypeName() const {
  return "IM.Live.IMLiveKickUser";
}


// ===================================================================

#ifndef _MSC_VER
const int IMLiveUserOfflineException::kUserImIdFieldNumber;
const int IMLiveUserOfflineException::kLiveIdFieldNumber;
const int IMLiveUserOfflineException::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMLiveUserOfflineException::IMLiveUserOfflineException()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Live.IMLiveUserOfflineException)
}

void IMLiveUserOfflineException::InitAsDefaultInstance() {
}

IMLiveUserOfflineException::IMLiveUserOfflineException(const IMLiveUserOfflineException& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Live.IMLiveUserOfflineException)
}

void IMLiveUserOfflineException::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  live_id_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMLiveUserOfflineException::~IMLiveUserOfflineException() {
  // @@protoc_insertion_point(destructor:IM.Live.IMLiveUserOfflineException)
  SharedDtor();
}

void IMLiveUserOfflineException::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMLiveUserOfflineException::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMLiveUserOfflineException& IMLiveUserOfflineException::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eLive_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eLive_2eproto();
#endif
  return *default_instance_;
}

IMLiveUserOfflineException* IMLiveUserOfflineException::default_instance_ = NULL;

IMLiveUserOfflineException* IMLiveUserOfflineException::New() const {
  return new IMLiveUserOfflineException;
}

void IMLiveUserOfflineException::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMLiveUserOfflineException*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(user_im_id_, live_id_);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMLiveUserOfflineException::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Live.IMLiveUserOfflineException)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_live_id;
        break;
      }

      // required uint32 live_id = 2;
      case 2: {
        if (tag == 16) {
         parse_live_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &live_id_)));
          set_has_live_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Live.IMLiveUserOfflineException)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Live.IMLiveUserOfflineException)
  return false;
#undef DO_
}

void IMLiveUserOfflineException::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Live.IMLiveUserOfflineException)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // required uint32 live_id = 2;
  if (has_live_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->live_id(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Live.IMLiveUserOfflineException)
}

int IMLiveUserOfflineException::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required uint32 live_id = 2;
    if (has_live_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->live_id());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMLiveUserOfflineException::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMLiveUserOfflineException*>(&from));
}

void IMLiveUserOfflineException::MergeFrom(const IMLiveUserOfflineException& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_live_id()) {
      set_live_id(from.live_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMLiveUserOfflineException::CopyFrom(const IMLiveUserOfflineException& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMLiveUserOfflineException::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMLiveUserOfflineException::Swap(IMLiveUserOfflineException* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    std::swap(live_id_, other->live_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMLiveUserOfflineException::GetTypeName() const {
  return "IM.Live.IMLiveUserOfflineException";
}


// ===================================================================

#ifndef _MSC_VER
const int IMLiveRoomClose::kLiveIdFieldNumber;
const int IMLiveRoomClose::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMLiveRoomClose::IMLiveRoomClose()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Live.IMLiveRoomClose)
}

void IMLiveRoomClose::InitAsDefaultInstance() {
}

IMLiveRoomClose::IMLiveRoomClose(const IMLiveRoomClose& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Live.IMLiveRoomClose)
}

void IMLiveRoomClose::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  live_id_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMLiveRoomClose::~IMLiveRoomClose() {
  // @@protoc_insertion_point(destructor:IM.Live.IMLiveRoomClose)
  SharedDtor();
}

void IMLiveRoomClose::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMLiveRoomClose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMLiveRoomClose& IMLiveRoomClose::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eLive_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eLive_2eproto();
#endif
  return *default_instance_;
}

IMLiveRoomClose* IMLiveRoomClose::default_instance_ = NULL;

IMLiveRoomClose* IMLiveRoomClose::New() const {
  return new IMLiveRoomClose;
}

void IMLiveRoomClose::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    live_id_ = 0u;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMLiveRoomClose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Live.IMLiveRoomClose)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 live_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &live_id_)));
          set_has_live_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Live.IMLiveRoomClose)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Live.IMLiveRoomClose)
  return false;
#undef DO_
}

void IMLiveRoomClose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Live.IMLiveRoomClose)
  // required uint32 live_id = 1;
  if (has_live_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->live_id(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Live.IMLiveRoomClose)
}

int IMLiveRoomClose::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 live_id = 1;
    if (has_live_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->live_id());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMLiveRoomClose::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMLiveRoomClose*>(&from));
}

void IMLiveRoomClose::MergeFrom(const IMLiveRoomClose& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_live_id()) {
      set_live_id(from.live_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMLiveRoomClose::CopyFrom(const IMLiveRoomClose& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMLiveRoomClose::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void IMLiveRoomClose::Swap(IMLiveRoomClose* other) {
  if (other != this) {
    std::swap(live_id_, other->live_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMLiveRoomClose::GetTypeName() const {
  return "IM.Live.IMLiveRoomClose";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Live
}  // namespace IM

// @@protoc_insertion_point(global_scope)
